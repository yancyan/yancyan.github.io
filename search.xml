<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>领域驱动设计 | 战略设计&amp;&amp;战术设计</title>
      <link href="/2021/06/07/ddd/ddd/"/>
      <url>/2021/06/07/ddd/ddd/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>对于领域，我们习惯的描述为金融领域、制药领域、化工领域和建筑领域等。在各领域内都有自己的各种业务规则，如何把控这些规则变化，应对各领域的复杂知识，一般采用分而治之。领域驱动设计常以战略设计和战术设计将整个领域完整的展现出来，其作用范围即面向技术也面向业务。从战略角度规划系统，划分领域。而从战术角度在技术层面指导我们如何设计。</p><h2 id="战略设计"><a href="#战略设计" class="headerlink" title="战略设计"></a>战略设计</h2><h3 id="1-统一语言"><a href="#1-统一语言" class="headerlink" title="1. 统一语言"></a>1. 统一语言</h3><p>如何提炼领域知识，有很多种方法，如事件风暴、用例分析方法、用户故事设置各种会议等，最终目的是提炼出领域知识，在提炼过程中达成的描述上的一致性，包含系统目标、系统范围和系统功能等。</p><h3 id="2-领域拆分"><a href="#2-领域拆分" class="headerlink" title="2. 领域拆分"></a>2. 领域拆分</h3><p>领域本身是复杂无边际的，借助分而治之将问题逐级细分来降低业务的复杂度和技术复杂度，将复杂的领域知识划分出清晰的边界，反过来控制着划分后不那么复杂的世界，即领域拆分以后的子领域</p><h3 id="3-子域拆分"><a href="#3-子域拆分" class="headerlink" title="3. 子域拆分"></a>3. 子域拆分</h3><p>在解决实际问题时，我们习惯将问题进行拆分，依据各不相同，在领域驱动设计中，更偏向基于业务的拆分，降低业务复杂度，也分离技术实现的复杂度。按业务拆分以后的子领域在权重上存在差异，依照重要性和功能分为三类。</p><p><strong>核心域</strong></p><p>核心服务，代表产品的核心竞争力</p><p><strong>支撑域</strong></p><p>支撑服务，需要但是又达不到核心价值，围绕产品内部需要，但是又不能单独变更为第三方服务</p><p><strong>通用域</strong></p><p>体现为中间件服务或第三方服务，</p><h3 id="4-界限上下文"><a href="#4-界限上下文" class="headerlink" title="4. 界限上下文"></a>4. 界限上下文</h3><p>在领域/子域中，我们会创建一个概念上的领域边界，在这个边界中，任何领域对象都只表示特定于该边界内部确切的含义，这样的边界就称为边界上下文。</p><h3 id="5-上下文识别"><a href="#5-上下文识别" class="headerlink" title="5. 上下文识别"></a>5. 上下文识别</h3><p>对上下文的识别没有可遵循的标准，从不同的角度切入会识别到不同的上下文。</p><p>我们识别上下文的目的是为了控制上下文，控制上下文边界和大小，为了保住上下文不会因过度成长而崩溃或过度伸缩而失去价值。</p><h3 id="6-上下文映射"><a href="#6-上下文映射" class="headerlink" title="6. 上下文映射"></a>6. 上下文映射</h3><p>如何组织上下文，使其协作执行，领域驱动设计提出了几种常见模式</p><ul><li>合作关系：同声同死</li><li>共享内核：上下文共享领域实体</li><li>客户方和供应方：上下游依赖</li><li>遵奉：下游顺应上游</li><li>各行其道： 相互隔离，互不影响</li><li>防腐层：上下游中间增加屏障</li><li>开放主机服务：上下游中间增加协议，规范下游堆上游的集成</li></ul><p>为了实现上下文映射，将不同上下文连贯起来，常见借助如RPC、HTTP、消息队列等方式。</p><h3 id="7-分层架构"><a href="#7-分层架构" class="headerlink" title="7. 分层架构"></a>7. 分层架构</h3><p>界限上下文属于架构设计层次，主要针对的是层次的垂直切分，按照经典的DDD分层结构，共分四层：</p><ol><li>User Interface 用户界面层，向用户展示信息或传入用户命令</li><li>Application 应用层，协调应用的活动，但是不包含业务逻辑，通过编排领域模型，使他们相互协作</li><li>Domain 领域层</li><li>Infrastructure 基础实施层，提供公共的基础设施组件，如持久化机制，消息管道的读取和写入等</li></ol><h2 id="战术设计"><a href="#战术设计" class="headerlink" title="战术设计"></a>战术设计</h2><p>相比于战略设计，战术设计更侧重于怎么执行，详细的设计和编码</p><h3 id="1-聚合"><a href="#1-聚合" class="headerlink" title="1. 聚合"></a>1. 聚合</h3><p>聚合本身是由一个或多个实体及值对象组成，其中一个实体作为聚合根，管理着内部关联的实体与值对象，对外代表着聚合，外部来访者可以通过聚合根进行访问。</p><h3 id="2-实体"><a href="#2-实体" class="headerlink" title="2. 实体"></a>2. 实体</h3><p>拥有唯一的身份标识符，内含属性作为该实体的静态特征作为聚合所拥有的领域知识，拥有着自身相关的领域知识</p><h3 id="3-值对象"><a href="#3-值对象" class="headerlink" title="3. 值对象"></a>3. 值对象</h3><p>基础类型的延申，既能封装基础类型，又能约束内部属性间的关系，还能拥有自身的领域行为，而与实体的而区别是没有唯一标识。</p><h3 id="4-聚合拆分"><a href="#4-聚合拆分" class="headerlink" title="4. 聚合拆分"></a>4. 聚合拆分</h3><h3 id="5-聚合协作"><a href="#5-聚合协作" class="headerlink" title="5. 聚合协作"></a>5. 聚合协作</h3><h3 id="6-应用服务"><a href="#6-应用服务" class="headerlink" title="6. 应用服务"></a>6. 应用服务</h3><h3 id="7-领域服务"><a href="#7-领域服务" class="headerlink" title="7. 领域服务"></a>7. 领域服务</h3><h3 id="8-领域事件"><a href="#8-领域事件" class="headerlink" title="8. 领域事件"></a>8. 领域事件</h3><h3 id="9-资源库"><a href="#9-资源库" class="headerlink" title="9. 资源库"></a>9. 资源库</h3><h3 id="10-工厂"><a href="#10-工厂" class="headerlink" title="10. 工厂"></a>10. 工厂</h3><h3 id="7-分层架构-1"><a href="#7-分层架构-1" class="headerlink" title="7. 分层架构"></a>7. 分层架构</h3>]]></content>
      
      
      <categories>
          
          <category> DDD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 领域驱动设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令模式</title>
      <link href="/2021/03/22/she-ji-mo-shi/command/"/>
      <url>/2021/03/22/she-ji-mo-shi/command/</url>
      
        <content type="html"><![CDATA[<p>命令模式是把一个请求或者操作封装到一个对象中。命令模式允许系统使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的<strong>撤销和恢复</strong>功能。</p><h2 id="命令模式结构"><a href="#命令模式结构" class="headerlink" title="命令模式结构"></a>命令模式结构</h2><p>命令模式是对命令的封装。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</p><p>命令允许请求的一方和接收请求的一方能够独立演化，从而具有以下的优点：</p><ol><li>命令模式使新的命令很容易地被加入到系统里。</li><li>允许接收请求的一方决定是否要否决请求。</li><li>能较容易地设计一个命令队列。</li><li>可以容易地实现对请求的撤销和恢复。</li><li>在需要的情况下，可以较容易地将命令记入日志。</li></ol><p><img src="/images/command_01.png"></p><p>命令模式涉及到五个角色，它们分别是：</p><ul><li>客户端(Client)角色：创建一个具体命令(ConcreteCommand)对象并确定其接收者。</li><li>命令(Command)角色：声明了一个给所有具体命令类的抽象接口。</li><li>具体命令(ConcreteCommand)角色：定义一个接收者和行为之间的弱耦合；实现execute()方法，负责调用接收者的相应操作。execute()方法通常叫做执行方法。</li><li>请求者(Invoker)角色：负责调用命令对象执行请求，相关的方法叫做行动方法。</li><li>接收者(Receiver)角色：负责具体实施和执行一个请求。任何一个类都可以成为接收者，实施和执行请求的方法叫做行动方法。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Receiver</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/** 真正执行命令相应的操作 */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Command</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/** 执行方法 */</span>    <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteCommand</span> <span class="token keyword">implements</span> <span class="token class-name">Command</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Receiver</span> receiver <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">ConcreteCommand</span><span class="token punctuation">(</span><span class="token class-name">Receiver</span> receiver<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>receiver <span class="token operator">=</span> receiver<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        receiver<span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Invoker</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Command</span> command <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Invoker</span><span class="token punctuation">(</span><span class="token class-name">Command</span> command<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>command <span class="token operator">=</span> command<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        command<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//创建接收者</span>        <span class="token class-name">Receiver</span> receiver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Receiver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//创建命令对象，设定它的接收者</span>        <span class="token class-name">Command</span> command <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteCommand</span><span class="token punctuation">(</span>receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//创建请求者，把命令对象设置进去</span>        <span class="token class-name">Invoker</span> invoker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Invoker</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//执行方法</span>        invoker<span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="录音机示例"><a href="#录音机示例" class="headerlink" title="录音机示例"></a>录音机示例</h2><p>小女孩茱丽(Julia)有一个盒式录音机，此录音机有播音(Play)、倒带(Rewind)和停止(Stop)功能，录音机的键盘便是请求者(Invoker)角色；茱丽(Julia)是客户端角色，而录音机便是接收者角色。Command类扮演抽象命令角色，而PlayCommand、StopCommand和RewindCommand便是具体命令类。茱丽(Julia)不需要知道播音(play)、倒带(rewind)和停止(stop)功能是怎么具体执行的，这些命令执行的细节全都由键盘(Keypad)具体实施。茱丽(Julia)只需要在键盘上按下相应的键便可以了。</p><p><img src="/images/command_02.png"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 接收者角色，由录音机类扮演</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AudioPlayer</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"播放..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rewind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"倒带..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"停止..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Command</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 执行方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PlayCommand</span> <span class="token keyword">implements</span> <span class="token class-name">Command</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">AudioPlayer</span> myAudio<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">PlayCommand</span><span class="token punctuation">(</span><span class="token class-name">AudioPlayer</span> audioPlayer<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        myAudio <span class="token operator">=</span> audioPlayer<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 执行方法     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        myAudio<span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RewindCommand</span> <span class="token keyword">implements</span> <span class="token class-name">Command</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">AudioPlayer</span> myAudio<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">RewindCommand</span><span class="token punctuation">(</span><span class="token class-name">AudioPlayer</span> audioPlayer<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        myAudio <span class="token operator">=</span> audioPlayer<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        myAudio<span class="token punctuation">.</span><span class="token function">rewind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StopCommand</span> <span class="token keyword">implements</span> <span class="token class-name">Command</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">AudioPlayer</span> myAudio<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">StopCommand</span><span class="token punctuation">(</span><span class="token class-name">AudioPlayer</span> audioPlayer<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        myAudio <span class="token operator">=</span> audioPlayer<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        myAudio<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Keypad</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Command</span> playCommand<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Command</span> rewindCommand<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Command</span> stopCommand<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPlayCommand</span><span class="token punctuation">(</span><span class="token class-name">Command</span> playCommand<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>playCommand <span class="token operator">=</span> playCommand<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setRewindCommand</span><span class="token punctuation">(</span><span class="token class-name">Command</span> rewindCommand<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>rewindCommand <span class="token operator">=</span> rewindCommand<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setStopCommand</span><span class="token punctuation">(</span><span class="token class-name">Command</span> stopCommand<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>stopCommand <span class="token operator">=</span> stopCommand<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 执行播放方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        playCommand<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 执行倒带方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rewind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        rewindCommand<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 执行播放方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        stopCommand<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Julia</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span>args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//创建接收者对象</span>        <span class="token class-name">AudioPlayer</span> audioPlayer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AudioPlayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//创建命令对象</span>        <span class="token class-name">Command</span> playCommand <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PlayCommand</span><span class="token punctuation">(</span>audioPlayer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Command</span> rewindCommand <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RewindCommand</span><span class="token punctuation">(</span>audioPlayer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Command</span> stopCommand <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StopCommand</span><span class="token punctuation">(</span>audioPlayer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//创建请求者对象</span>        <span class="token class-name">Keypad</span> keypad <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Keypad</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        keypad<span class="token punctuation">.</span><span class="token function">setPlayCommand</span><span class="token punctuation">(</span>playCommand<span class="token punctuation">)</span><span class="token punctuation">;</span>        keypad<span class="token punctuation">.</span><span class="token function">setRewindCommand</span><span class="token punctuation">(</span>rewindCommand<span class="token punctuation">)</span><span class="token punctuation">;</span>        keypad<span class="token punctuation">.</span><span class="token function">setStopCommand</span><span class="token punctuation">(</span>stopCommand<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//测试</span>        keypad<span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        keypad<span class="token punctuation">.</span><span class="token function">rewind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        keypad<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        keypad<span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        keypad<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="宏命令"><a href="#宏命令" class="headerlink" title="宏命令"></a>宏命令</h2><p>宏命令简单点说就是包含多个命令的命令，是一个命令的组合</p><p>设想茱丽的录音机有一个记录功能，可以把一个一个的命令记录下来，再在任何需要的时候重新把这些记录下来的命令一次性执行，这就是所谓的宏命令集功能。因此，茱丽的录音机系统现在有四个键，分别为播音、倒带、停止和宏命令功能。此时系统的设计与前面的设计相比有所增强，主要体现在Julia类现在有了一个新方法，用以操作宏命令键。</p><p><img src="/images/command_03.png"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">MacroCommand</span> <span class="token keyword">extends</span> <span class="token class-name">Command</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 宏命令聚集的管理方法     * 可以添加一个成员命令     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Command</span> cmd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 宏命令聚集的管理方法     * 可以删除一个成员命令     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Command</span> cmd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MacroAudioCommand</span> <span class="token keyword">implements</span> <span class="token class-name">MacroCommand</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Command</span><span class="token punctuation">></span></span> commandList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Command</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 宏命令聚集管理方法     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Command</span> cmd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        commandList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 宏命令聚集管理方法     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Command</span> cmd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        commandList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 执行方法     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Command</span> cmd <span class="token operator">:</span> commandList<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cmd<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Julia</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span>args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//创建接收者对象</span>        <span class="token class-name">AudioPlayer</span> audioPlayer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AudioPlayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//创建命令对象</span>        <span class="token class-name">Command</span> playCommand <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PlayCommand</span><span class="token punctuation">(</span>audioPlayer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Command</span> rewindCommand <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RewindCommand</span><span class="token punctuation">(</span>audioPlayer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Command</span> stopCommand <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StopCommand</span><span class="token punctuation">(</span>audioPlayer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">MacroCommand</span> marco <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MacroAudioCommand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        marco<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>playCommand<span class="token punctuation">)</span><span class="token punctuation">;</span>        marco<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>rewindCommand<span class="token punctuation">)</span><span class="token punctuation">;</span>        marco<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>stopCommand<span class="token punctuation">)</span><span class="token punctuation">;</span>        marco<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="命令模式的优点"><a href="#命令模式的优点" class="headerlink" title="命令模式的优点"></a>命令模式的优点</h2><ul><li>更松散的耦合<br>命令模式使得发起命令的对象——客户端，和具体实现命令的对象——接收者对象完全解耦，也就是说发起命令的对- </li><li>更动态的控制<br>命令模式把请求封装起来，可以动态地对它进行参数化、队列化和日志化等操作，从而使得系统更灵活。</li><li>很自然的复合命令<br>命令模式中的命令对象能够很容易地组合成复合命令，也就是宏命令，从而使系统操作更简单，功能更强大。</li><li>更好的扩展性<br>由于发起命令的对象和具体的实现完全解耦，因此扩展新的命令就很容易，只需要实现新的命令对象，然后在装配的时候，把具体的实现对象设置到命令对象中，然后就可以使用这个命令对象，已有的实现完全不用变化。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰器模式</title>
      <link href="/2021/03/19/she-ji-mo-shi/decorator/"/>
      <url>/2021/03/19/she-ji-mo-shi/decorator/</url>
      
        <content type="html"><![CDATA[<p>装饰模式又名包装(Wrapper)模式。装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任。装饰模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。</p><h2 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h2><p><img src="/images/decorator_01.png"></p><p>在装饰模式中的角色有：</p><ul><li>抽象构件(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。</li><li>具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类。</li><li>装饰(Decorator)角色：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。</li><li>具体装饰(ConcreteDecorator)角色：负责给构件对象“贴上”附加的责任。</li></ul><h2 id="编程模型示例"><a href="#编程模型示例" class="headerlink" title="编程模型示例"></a>编程模型示例</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 抽象构件角色</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Component</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sampleOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 具体构件角色</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteComponent</span> <span class="token keyword">implements</span> <span class="token class-name">Component</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sampleOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 写相关的业务代码</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 装饰角色</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Decorator</span> <span class="token keyword">implements</span> <span class="token class-name">Component</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Component</span> component<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Decorator</span><span class="token punctuation">(</span><span class="token class-name">Component</span> component<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>component <span class="token operator">=</span> component<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sampleOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 委派给构件</span>        component<span class="token punctuation">.</span><span class="token function">sampleOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 具体装饰角色</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteDecoratorA</span> <span class="token keyword">extends</span> <span class="token class-name">Decorator</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">ConcreteDecoratorA</span><span class="token punctuation">(</span><span class="token class-name">Component</span> component<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sampleOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>　　　　　<span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">sampleOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 写相关的业务代码</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteDecoratorB</span> <span class="token keyword">extends</span> <span class="token class-name">Decorator</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">ConcreteDecoratorB</span><span class="token punctuation">(</span><span class="token class-name">Component</span> component<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sampleOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>　　　　  <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">sampleOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 写相关的业务代码</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="装饰模式简化"><a href="#装饰模式简化" class="headerlink" title="装饰模式简化"></a>装饰模式简化</h2><p>如果只有一个ConcreteComponent类，那么可以考虑去掉抽象的Component类（接口），把Decorator作为一个ConcreteComponent子类。如下图所示：<br><img src="/images/decorator_02.png"></p><p>如果只有一个ConcreteDecorator类，那么就没有必要建立一个单独的Decorator类，而可以把Decorator和ConcreteDecorator的责任合并成一个类。甚至在只有两个ConcreteDecorator类的情况下，都可以这样做。如下图所示：<br><img src="/images/decorator_03.png"></p><h2 id="装饰模式的优缺点"><a href="#装饰模式的优缺点" class="headerlink" title="装饰模式的优缺点"></a>装饰模式的优缺点</h2><h3 id="装饰模式的优点"><a href="#装饰模式的优点" class="headerlink" title="装饰模式的优点"></a>装饰模式的优点</h3><ol><li>装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。装饰模式允许系统动态决定“贴上”一个需要的“装饰”，或者除掉一个不需要的“装饰”。继承关系则不同，继承关系是静态的，它在系统运行前就决定了。</li><li>通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。</li></ol><h3 id="装饰模式的缺点"><a href="#装饰模式的缺点" class="headerlink" title="装饰模式的缺点"></a>装饰模式的缺点</h3><p>由于使用装饰模式，可以比使用继承关系需要较少数目的类。使用较少的类，当然使设计比较易于进行。但是，在另一方面，使用装饰模式会产生比使用继承关系更多的对象。更多的对象会使得查错变得困难，特别是这些对象看上去都很相像。</p><h2 id="JAVA-I-O库中的应用"><a href="#JAVA-I-O库中的应用" class="headerlink" title="JAVA I/O库中的应用"></a>JAVA I/O库中的应用</h2><p>Java I/O库需要很多性能的各种组合，如果这些性能都是用继承的方法实现的，那么每一种组合都需要一个类，这样就会造成大量性能重复的类出现。而如果采用装饰模式，那么类的数目就会大大减少，性能的重复也可以减至最少。因此装饰模式是Java I/O库的基本模式。</p><p>Java I/O库的对象结构图如下，由于Java I/O的对象众多，因此只画出InputStream的部分。<br><img src="/images/decorator_04.png"></p><p>根据上图可以看出：</p><ul><li><p>抽象构件(Component)角色：由InputStream扮演。这是一个抽象类，为各种子类型提供统一的接口。</p></li><li><p>具体构件(ConcreteComponent)角色：由ByteArrayInputStream、FileInputStream、PipedInputStream、StringBufferInputStream等类扮演。它们实现了抽象构件角色所规定的接口。</p></li><li><p>抽象装饰(Decorator)角色：由FilterInputStream扮演。它实现了InputStream所规定的接口。</p></li><li><p>具体装饰(ConcreteDecorator)角色：由几个类扮演，分别是BufferedInputStream、DataInputStream以及两个不常用到的类LineNumberInputStream、PushbackInputStream。</p></li></ul><h2 id="半透明的装饰模式"><a href="#半透明的装饰模式" class="headerlink" title="半透明的装饰模式"></a>半透明的装饰模式</h2><p>装饰模式和适配器模式都是“包装模式(Wrapper Pattern)”，它们都是通过封装其他对象达到设计的目的的，但是它们的形态有很大区别。</p><p>理想的装饰模式在对被装饰对象进行功能增强的同时，要求具体构件角色、装饰角色的接口与抽象构件角色的接口完全一致。而适配器模式则不然，一般而言，适配器模式并不要求对源对象的功能进行增强，但是会改变源对象的接口，以便和目标接口相符合。</p><p>装饰模式有透明和半透明两种，这两种的区别就在于装饰角色的接口与抽象构件角色的接口是否完全一致。透明的装饰模式也就是理想的装饰模式，要求具体构件角色、装饰角色的接口与抽象构件角色的接口完全一致。相反，如果装饰角色的接口与抽象构件角色接口不一致，<strong>也就是说装饰角色的接口比抽象构件角色的接口宽的话，装饰角色实际上已经成了一个适配器角色</strong>，这种装饰模式也是可以接受的，称为“半透明”的装饰模式</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>享元模式</title>
      <link href="/2021/03/19/she-ji-mo-shi/flyweight/"/>
      <url>/2021/03/19/she-ji-mo-shi/flyweight/</url>
      
        <content type="html"><![CDATA[<p>Flyweight在拳击比赛中指最轻量级，选择使用“享元模式”的意译，是因为这样更能反映模式的用意。享元模式是对象的结构模式。享元模式以共享的方式高效地支持大量的细粒度对象。</p><h2 id="享元模式的结构"><a href="#享元模式的结构" class="headerlink" title="享元模式的结构"></a>享元模式的结构</h2><p>享元模式采用一个共享来避免大量拥有相同内容对象的开销。这种开销最常见、最直观的就是内存的损耗。享元对象能做到共享的关键是区分内蕴状态(Internal State)和外蕴状态(External State)。</p><ul><li><p>内蕴状态是存储在享元对象内部的，并且是不会随环境的改变而有所不同。因此，一个享元可以具有内蕴状态并可以共享。</p></li><li><p>外蕴状态是随环境的改变而改变的、不可以共享的。享元对象的外蕴状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。外蕴状态不可以影响享元对象的内蕴状态，它们是相互独立的。</p></li></ul><p>享元模式可以分成单纯享元模式和复合享元模式两种形式。</p><h2 id="单纯享元模式"><a href="#单纯享元模式" class="headerlink" title="单纯享元模式"></a>单纯享元模式</h2><p><img src="/images/flyweight_01.png"><br>单纯享元模式所涉及到的角色如下：</p><ul><li><p>抽象享元(Flyweight)角色 ：给出一个抽象接口，以规定出所有具体享元角色需要实现的方法。</p></li><li><p>具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。</p></li><li><p>享元工厂(FlyweightFactory)角色 ：本角色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有一个符合要求的享元对象。如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个合适的享元对象。</p></li></ul><p>抽象享元角色类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Flyweight</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//一个示意性方法，参数state是外蕴状态</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token class-name">String</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>具体享元角色类ConcreteFlyweight有一个内蕴状态，它的值应当在享元对象被创建时赋予。所有的内蕴状态在对象创建之后，就不会再改变了。 如果有外蕴状态的话，所有的外部状态都必须存储在客户端，在使用享元对象时，再由客户端传入享元对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFlyweight</span> <span class="token keyword">implements</span> <span class="token class-name">Flyweight</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Character</span> intrinsicState <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">ConcreteFlyweight</span><span class="token punctuation">(</span><span class="token class-name">Character</span> state<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>intrinsicState <span class="token operator">=</span> state<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token class-name">String</span> state<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// TODO Auto-generated method stub</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Intrinsic State = "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>intrinsicState<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Extrinsic State = "</span> <span class="token operator">+</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>享元工厂角色类，客户端不可以直接将具体享元类实例化，而必须通过一个工厂对象，利用一个factory()方法得到享元对象。一般而言，享元工厂对象在整个系统中只有一个，因此也可以使用单例模式。</p><p>当客户端需要单纯享元对象的时候，需要调用享元工厂的factory()方法，并传入所需的单纯享元对象的内蕴状态，由工厂方法产生所需要的享元对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FlyweightFactory</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span><span class="token class-name">Flyweight</span><span class="token punctuation">></span></span> files <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span><span class="token class-name">Flyweight</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Flyweight</span> <span class="token function">factory</span><span class="token punctuation">(</span><span class="token class-name">Character</span> state<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//先从缓存中查找对象</span>        <span class="token class-name">Flyweight</span> fly <span class="token operator">=</span> files<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>fly <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//如果对象不存在则创建一个新的Flyweight对象</span>            fly <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteFlyweight</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//把这个新的Flyweight对象添加到缓存中</span>            files<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> fly<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> fly<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// TODO Auto-generated method stub</span>        <span class="token class-name">FlyweightFactory</span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FlyweightFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Flyweight</span> fly <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">factory</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Character</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        fly<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token string">"First Call"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                fly <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">factory</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Character</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        fly<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token string">"Second Call"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                fly <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">factory</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Character</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        fly<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token string">"Third Call"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="复合享元模式"><a href="#复合享元模式" class="headerlink" title="复合享元模式"></a>复合享元模式</h2><p>在单纯享元模式中，所有的享元对象都是单纯享元对象，也就是说都是可以直接共享的。还有一种较为复杂的情况，将一些单纯享元使用合成模式加以复合，形成复合享元对象。这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。</p><p><img src="/images/flyweight_02.png"></p><p>复合享元角色所涉及到的角色如下：</p><ul><li><p>抽象享元(Flyweight)角色 ：给出一个抽象接口，以规定出所有具体享元角色需要实现的方法。</p></li><li><p>具体享元(ConcreteFlyweight)角色：实现抽象享元角色所规定出的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。</p></li><li><p>复合享元(ConcreteCompositeFlyweight)角色 ：复合享元角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成为多个本身是单纯享元对象的组合。复合享元角色又称作不可共享的享元对象。</p></li><li><p>享元工厂(FlyweightFactory)角色 ：本角 色负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有 一个符合要求的享元对象。如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个 合适的享元对象。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Flyweight</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//一个示意性方法，参数state是外蕴状态</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token class-name">String</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFlyweight</span> <span class="token keyword">implements</span> <span class="token class-name">Flyweight</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Character</span> intrinsicState <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">ConcreteFlyweight</span><span class="token punctuation">(</span><span class="token class-name">Character</span> state<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>intrinsicState <span class="token operator">=</span> state<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token class-name">String</span> state<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// TODO Auto-generated method stub</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Intrinsic State = "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>intrinsicState<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Extrinsic State = "</span> <span class="token operator">+</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>享元工厂角色类，客户端不可以直接将具体享元类实例化，而必须通过一个工厂对象，利用一个factory()方法得到享元对象。一般而言，享元工厂对象在整个系统中只有一个，因此也可以使用单例模式。</p><p>当客户端需要单纯享元对象的时候，需要调用享元工厂的factory()方法，并传入所需的单纯享元对象的内蕴状态，由工厂方法产生所需要的享元对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FlyweightFactory</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span><span class="token class-name">Flyweight</span><span class="token punctuation">></span></span> files <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span><span class="token class-name">Flyweight</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Flyweight</span> <span class="token function">factory</span><span class="token punctuation">(</span><span class="token class-name">Character</span> state<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//先从缓存中查找对象</span>        <span class="token class-name">Flyweight</span> fly <span class="token operator">=</span> files<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>fly <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token comment">//如果对象不存在则创建一个新的Flyweight对象</span>            fly <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteFlyweight</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//把这个新的Flyweight对象添加到缓存中</span>            files<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> fly<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> fly<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteCompositeFlyweight</span> <span class="token keyword">implements</span> <span class="token class-name">Flyweight</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span><span class="token class-name">Flyweight</span><span class="token punctuation">></span></span> files <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span><span class="token class-name">Flyweight</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Character</span> key <span class="token punctuation">,</span> <span class="token class-name">Flyweight</span> fly<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        files<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>fly<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token class-name">String</span> state<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Flyweight</span> fly <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o <span class="token operator">:</span> files<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            fly <span class="token operator">=</span> files<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>            fly<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FlyweightFactory</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span><span class="token class-name">Flyweight</span><span class="token punctuation">></span></span> files <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span><span class="token class-name">Flyweight</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Flyweight</span> <span class="token function">factory</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">></span></span> compositeState<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">ConcreteCompositeFlyweight</span> compositeFly <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteCompositeFlyweight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Character</span> state <span class="token operator">:</span> compositeState<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            compositeFly<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">factory</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> compositeFly<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">Flyweight</span> <span class="token function">factory</span><span class="token punctuation">(</span><span class="token class-name">Character</span> state<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Flyweight</span> fly <span class="token operator">=</span> files<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>fly <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            fly <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteFlyweight</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>            files<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> fly<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> fly<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">></span></span> compositeState <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        compositeState<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        compositeState<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        compositeState<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        compositeState<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        compositeState<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">FlyweightFactory</span> flyFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FlyweightFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Flyweight</span> compositeFly1 <span class="token operator">=</span> flyFactory<span class="token punctuation">.</span><span class="token function">factory</span><span class="token punctuation">(</span>compositeState<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Flyweight</span> compositeFly2 <span class="token operator">=</span> flyFactory<span class="token punctuation">.</span><span class="token function">factory</span><span class="token punctuation">(</span>compositeState<span class="token punctuation">)</span><span class="token punctuation">;</span>        compositeFly1<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token string">"Composite Call"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"---------------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"复合享元模式是否可以共享对象："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>compositeFly1 <span class="token operator">==</span> compositeFly2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Character</span> state <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span>        <span class="token class-name">Flyweight</span> fly1 <span class="token operator">=</span> flyFactory<span class="token punctuation">.</span><span class="token function">factory</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Flyweight</span> fly2 <span class="token operator">=</span> flyFactory<span class="token punctuation">.</span><span class="token function">factory</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"单纯享元模式是否可以共享对象："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>fly1 <span class="token operator">==</span> fly2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="享元模式的优缺点"><a href="#享元模式的优缺点" class="headerlink" title="享元模式的优缺点"></a>享元模式的优缺点</h2><p>享元模式的优点在于它大幅度地降低内存中对象的数量。<br>但是，它做到这一点所付出的代价也是很高的</p><ul><li>享元模式使得系统更加复杂。为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑复杂化。</li><li>享元模式将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合成模式</title>
      <link href="/2021/03/19/she-ji-mo-shi/composite/"/>
      <url>/2021/03/19/she-ji-mo-shi/composite/</url>
      
        <content type="html"><![CDATA[<p>合成模式属于对象的结构模式，有时又叫做“部分——整体”模式。合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式可以使客户端将单纯元素与复合元素同等看待。</p><p><img src="/images/composite_01.png"></p><p>从图中可以看出，文件系统是一个树结构，树上长有节点。树的节点有两种，一种是树枝节点，即目录，有内部树结构，在图中涂有颜色；另一种是文件，即树叶节点，没有内部树结构。</p><p>显然，可以把目录和文件当做同一种对象同等对待和处理，这也就是合成模式的应用。</p><p>合成模式可以不提供父对象的管理方法，但是合成模式必须在合适的地方提供子对象的管理方法，诸如：add()、remove()、以及getChild()等。</p><p>合成模式的实现根据所实现接口的区别分为两种形式，分别称为安全式和透明式。</p><h2 id="安全式"><a href="#安全式" class="headerlink" title="安全式"></a>安全式</h2><p>安全的合成模式要求管理聚集的方法只出现在树枝构件类中，而不出现在树叶构件类中。<br><img src="/images/composite_02.png"></p><p>这种形式涉及到三个角色：</p><ol><li>抽象构件(Component)角色：这是一个抽象角色，它给参加组合的对象定义出公共的接口及其默认行为，可以用来管理所有的子对象。合成对象通常把它所包含的子对象当做类型为Component的对象。在安全式的合成模式里，构件角色并不定义出管理子对象的方法，这一定义由树枝构件对象给出。</li><li>树叶构件(Leaf)角色：树叶对象是没有下级子对象的对象，定义出参加组合的原始对象的行为。</li><li>树枝构件(Composite)角色：代表参加组合的有下级子对象的对象。树枝构件类给出所有的管理子对象的方法，如add()、remove()以及getChild()。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Component</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 输出组建自身的名称     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printStruct</span><span class="token punctuation">(</span><span class="token class-name">String</span> preStr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 树枝构件角色</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Composite</span> <span class="token keyword">implements</span> <span class="token class-name">Component</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Component</span><span class="token punctuation">></span></span> childComponents <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Component</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Composite</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addChild</span><span class="token punctuation">(</span><span class="token class-name">Component</span> child<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        childComponents<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">removeChild</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        childComponents<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Component</span><span class="token punctuation">></span></span> <span class="token function">getChild</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> childComponents<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printStruct</span><span class="token punctuation">(</span><span class="token class-name">String</span> preStr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>preStr <span class="token operator">+</span> <span class="token string">"+"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>childComponents <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            preStr <span class="token operator">+=</span> <span class="token string">"  "</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Component</span> c <span class="token operator">:</span> childComponents<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                c<span class="token punctuation">.</span><span class="token function">printStruct</span><span class="token punctuation">(</span>preStr<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 树叶构件角色</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Leaf</span> <span class="token keyword">implements</span> <span class="token class-name">Component</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Leaf</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printStruct</span><span class="token punctuation">(</span><span class="token class-name">String</span> preStr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// TODO Auto-generated method stub</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>preStr <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span>args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Composite</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Composite</span><span class="token punctuation">(</span><span class="token string">"服装"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Composite</span> c1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Composite</span><span class="token punctuation">(</span><span class="token string">"男装"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Composite</span> c2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Composite</span><span class="token punctuation">(</span><span class="token string">"女装"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">Leaf</span> leaf1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Leaf</span><span class="token punctuation">(</span><span class="token string">"衬衫"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Leaf</span> leaf2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Leaf</span><span class="token punctuation">(</span><span class="token string">"夹克"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Leaf</span> leaf3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Leaf</span><span class="token punctuation">(</span><span class="token string">"裙子"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Leaf</span> leaf4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Leaf</span><span class="token punctuation">(</span><span class="token string">"套装"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                root<span class="token punctuation">.</span><span class="token function">addChild</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token punctuation">.</span><span class="token function">addChild</span><span class="token punctuation">(</span>c2<span class="token punctuation">)</span><span class="token punctuation">;</span>        c1<span class="token punctuation">.</span><span class="token function">addChild</span><span class="token punctuation">(</span>leaf1<span class="token punctuation">)</span><span class="token punctuation">;</span>        c1<span class="token punctuation">.</span><span class="token function">addChild</span><span class="token punctuation">(</span>leaf2<span class="token punctuation">)</span><span class="token punctuation">;</span>        c2<span class="token punctuation">.</span><span class="token function">addChild</span><span class="token punctuation">(</span>leaf3<span class="token punctuation">)</span><span class="token punctuation">;</span>        c2<span class="token punctuation">.</span><span class="token function">addChild</span><span class="token punctuation">(</span>leaf4<span class="token punctuation">)</span><span class="token punctuation">;</span>                root<span class="token punctuation">.</span><span class="token function">printStruct</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>树枝构件类(Composite)给出了addChild()、removeChild()以及getChild()等方法的声明和实现，而树叶构件类则没有给出这些方法的声明或实现。这样的做法是安全的做法，由于这个特点，客户端应用程序不可能错误地调用树叶构件的聚集方法，因为树叶构件没有这些方法，调用会导致编译错误。</p><h2 id="透明式"><a href="#透明式" class="headerlink" title="透明式"></a>透明式</h2><p>透明式的合成模式要求所有的具体构件类，不论树枝构件还是树叶构件，均符合一个固定接口。<br><img src="/images/composite_03.png"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 抽象构件角色类</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Component</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">printStruct</span><span class="token punctuation">(</span><span class="token class-name">String</span> preStr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addChild</span><span class="token punctuation">(</span><span class="token class-name">Component</span> child<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token string">"对象不支持此功能"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">removeChild</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token string">"对象不支持此功能"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Component</span><span class="token punctuation">></span></span> <span class="token function">getChild</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token string">"对象不支持此功能"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 树枝构件角色类，此类将**实现改为继承**，其他地方无变化。</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Composite</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Component</span><span class="token punctuation">></span></span> childComponents <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Component</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Composite</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addChild</span><span class="token punctuation">(</span><span class="token class-name">Component</span> child<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        childComponents<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">removeChild</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        childComponents<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Component</span><span class="token punctuation">></span></span> <span class="token function">getChild</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> childComponents<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printStruct</span><span class="token punctuation">(</span><span class="token class-name">String</span> preStr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>preStr <span class="token operator">+</span> <span class="token string">"+"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>childComponents <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            preStr <span class="token operator">+=</span> <span class="token string">"  "</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Component</span> c <span class="token operator">:</span> childComponents<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                c<span class="token punctuation">.</span><span class="token function">printStruct</span><span class="token punctuation">(</span>preStr<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 树叶构件角色类，此类将**实现改为继承**，其他地方无变化。</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Leaf</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Leaf</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printStruct</span><span class="token punctuation">(</span><span class="token class-name">String</span> preStr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// TODO Auto-generated method stub</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>preStr <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Client调用, 不再区分Composite对象和Leaf对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span>args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Component</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Composite</span><span class="token punctuation">(</span><span class="token string">"服装"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Component</span> c1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Composite</span><span class="token punctuation">(</span><span class="token string">"男装"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Component</span> c2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Composite</span><span class="token punctuation">(</span><span class="token string">"女装"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">Component</span> leaf1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Leaf</span><span class="token punctuation">(</span><span class="token string">"衬衫"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Component</span> leaf2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Leaf</span><span class="token punctuation">(</span><span class="token string">"夹克"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Component</span> leaf3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Leaf</span><span class="token punctuation">(</span><span class="token string">"裙子"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Component</span> leaf4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Leaf</span><span class="token punctuation">(</span><span class="token string">"套装"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                root<span class="token punctuation">.</span><span class="token function">addChild</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span><span class="token punctuation">;</span>        root<span class="token punctuation">.</span><span class="token function">addChild</span><span class="token punctuation">(</span>c2<span class="token punctuation">)</span><span class="token punctuation">;</span>        c1<span class="token punctuation">.</span><span class="token function">addChild</span><span class="token punctuation">(</span>leaf1<span class="token punctuation">)</span><span class="token punctuation">;</span>        c1<span class="token punctuation">.</span><span class="token function">addChild</span><span class="token punctuation">(</span>leaf2<span class="token punctuation">)</span><span class="token punctuation">;</span>        c2<span class="token punctuation">.</span><span class="token function">addChild</span><span class="token punctuation">(</span>leaf3<span class="token punctuation">)</span><span class="token punctuation">;</span>        c2<span class="token punctuation">.</span><span class="token function">addChild</span><span class="token punctuation">(</span>leaf4<span class="token punctuation">)</span><span class="token punctuation">;</span>                root<span class="token punctuation">.</span><span class="token function">printStruct</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="两种实现方法的选择"><a href="#两种实现方法的选择" class="headerlink" title="两种实现方法的选择"></a>两种实现方法的选择</h2><p>这里所说的安全性合成模式是指：从客户端使用合成模式上看是否更安全，如果是安全的，那么就不会有发生误操作的可能，能访问的方法都是被支持的。</p><p>这里所说的透明性合成模式是指：从客户端使用合成模式上，是否需要区分到底是“树枝对象”还是“树叶对象”。如果是透明的，那就不用区分，对于客户而言，都是Compoent对象，具体的类型对于客户端而言是透明的，是无须关心的。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单工厂&amp;工厂方法&amp;抽象工厂</title>
      <link href="/2021/03/17/she-ji-mo-shi/gof-design-mode/"/>
      <url>/2021/03/17/she-ji-mo-shi/gof-design-mode/</url>
      
        <content type="html"><![CDATA[<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>简单工厂模式是类的创建模式，又叫做静态工厂方法（Static Factory Method）模式。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。</p><h3 id="简单工厂模式使用场景"><a href="#简单工厂模式使用场景" class="headerlink" title="简单工厂模式使用场景"></a>简单工厂模式使用场景</h3><p>拿登录功能来说，假如应用系统需要支持多种登录方式如：口令认证、域认证（口令认证通常是去数据库中验证用户，而域认证则是需要到微软的域中验证用户）。那么自然的做法就是建立一个各种登录方式都适用的接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Login</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">verify</span><span class="token punctuation">(</span><span class="token class-name">String</span> name <span class="token punctuation">,</span> <span class="token class-name">String</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DomainLogin</span> <span class="token keyword">implements</span> <span class="token class-name">Login</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">verify</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> password<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// TODO Auto-generated method stub</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PasswordLogin</span> <span class="token keyword">implements</span> <span class="token class-name">Login</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">verify</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">String</span> password<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// TODO Auto-generated method stub</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还需要一个工厂类LoginManager，根据调用者不同的要求，创建出不同的登录对象并返回。而如果碰到不合法的要求，会返回一个Runtime异常。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoginManager</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Login</span> <span class="token function">factory</span><span class="token punctuation">(</span><span class="token class-name">String</span> type<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">PasswordLogin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"passcode"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DomainLogin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>《JAVA与模式》一书中使用java.text.DataFormat类作为简单工厂模式的典型例子叙述。</p><h3 id="简单工厂模式的优点"><a href="#简单工厂模式的优点" class="headerlink" title="简单工厂模式的优点"></a>简单工厂模式的优点</h3><p>　　模式的核心是工厂类。这个类含有必要的逻辑判断，可以决定在什么时候创建哪一个登录验证类的实例，而调用者则可以免除直接创建对象的责任。简单工厂模式通过这种做法实现了对责任的分割，当系统引入新的登录方式的时候无需修改调用者。</p><h3 id="简单工厂模式的缺点"><a href="#简单工厂模式的缺点" class="headerlink" title="简单工厂模式的缺点"></a>简单工厂模式的缺点</h3><p>　　这个工厂类集中了所以的创建逻辑，当有复杂的多层次等级结构时，所有的业务逻辑都在这个工厂类中实现。什么时候它不能工作了，整个系统都会受到影响。</p><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>工厂方法模式是类的创建模式，用意是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。</p><h3 id="工厂方法模式使用场景"><a href="#工厂方法模式使用场景" class="headerlink" title="工厂方法模式使用场景"></a>工厂方法模式使用场景</h3><p>拿导出功能来说。如果系统需要支持对数据库中的员工薪资进行导出，支持多种格式（HTML、CSV、PDF等）且每种格式导出的结构有所不同（财务可能需要特定的格式方便核算）。</p><p>如果使用简单工厂模式，则工厂类必定过于臃肿。因为简单工厂模式只有一个工厂类，它需要处理所有的创建的逻辑。假如以上需求暂时只支持3种导出的格式以及2种导出的结构，那工厂类则需要6个if else来创建6种不同的类型。如果日后需求不断增加，则后果不堪设想。</p><p>　　这时候就需要工厂方法模式来处理以上需求。在工厂方法模式中，核心的工厂类不再负责所有的对象的创建，而是将具体创建的工作交给子类去做。这个核心类则摇身一变，成为了一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个类应当被实例化这种细节。</p><p>这种进一步抽象化的结果，使这种工厂方法模式可以用来允许系统在不修改具体工厂角色的情况下引进新的产品，这一特点无疑使得工厂方法模式具有超过简单工厂模式的优越性。下面就针对以上需求设计UML图：</p><p><img src="/images/factory_method_design_mode.png"></p><p>从上图可以看出，这个使用的工厂方法模式的系统涉及到以下角色：</p><ul><li><p>抽象工厂（ExportFactory）角色：担任这个角色的是工厂方法模式的核心，任何在模式中创建对象的工厂类必须实现这个接口。在实际的系统中，这个角色也常常使用抽象类实现。</p></li><li><p>具体工厂（ExportHtmlFactory、ExportPdfFactory）角色：担任这个角色的是实现了抽象工厂接口的具体JAVA类。具体工厂角色含有与业务密切相关的逻辑，并且受到使用者的调用以创建导出类（如：ExportStandardHtmlFile）。</p></li><li><p>抽象导出（ExportFile）角色：工厂方法模式所创建的对象的超类，也就是所有导出类的共同父类或共同拥有的接口。在实际的系统中，这个角色也常常使用抽象类实现。</p></li><li><p>具体导出（ExportStandardHtmlFile等）角色：这个角色实现了抽象导出（ExportFile）角色所声明的接口，工厂方法模式所创建的每一个对象都是某个具体导出角色的实例。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ExportFactory</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">ExportFile</span> <span class="token function">factory</span><span class="token punctuation">(</span><span class="token class-name">String</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExportHtmlFactory</span> <span class="token keyword">implements</span> <span class="token class-name">ExportFactory</span><span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">ExportFile</span> <span class="token function">factory</span><span class="token punctuation">(</span><span class="token class-name">String</span> type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// TODO Auto-generated method stub</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"standard"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ExportStandardHtmlFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"financial"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ExportFinancialHtmlFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExportPdfFactory</span> <span class="token keyword">implements</span> <span class="token class-name">ExportFactory</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">ExportFile</span> <span class="token function">factory</span><span class="token punctuation">(</span><span class="token class-name">String</span> type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// TODO Auto-generated method stub</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"standard"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ExportStandardPdfFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"financial"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ExportFinancialPdfFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ExportFile</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">export</span><span class="token punctuation">(</span><span class="token class-name">String</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExportFinancialHtmlFile</span> <span class="token keyword">implements</span> <span class="token class-name">ExportFile</span><span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">export</span><span class="token punctuation">(</span><span class="token class-name">String</span> data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// TODO Auto-generated method stub</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"导出财务版HTML文件"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExportFinancialPdfFile</span> <span class="token keyword">implements</span> <span class="token class-name">ExportFile</span><span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">export</span><span class="token punctuation">(</span><span class="token class-name">String</span> data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// TODO Auto-generated method stub</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"导出财务版PDF文件"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="工厂方法和简单工厂模式"><a href="#工厂方法和简单工厂模式" class="headerlink" title="工厂方法和简单工厂模式"></a>工厂方法和简单工厂模式</h3><p>工厂方法模式和简单工厂模式在结构上的不同很明显。工厂方法模式的核心是一个抽象工厂类，而简单工厂模式把核心放在一个具体类上。<br>　　如果系统需要加入一个新的导出类型，那么所需要的就是向系统中加入一个这个导出类以及所对应的工厂类。没有必要修改客户端，也没有必要修改抽象工厂角色或者其他已有的具体工厂角色。对于增加新的导出类型而言，这个系统完全支持“开-闭原则”。</p></li></ul><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂模式与工厂方法模式的最大区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则需要面对多个产品等级结构。</p><h3 id="场景问题"><a href="#场景问题" class="headerlink" title="场景问题"></a>场景问题</h3><p>　　举个生活中常见的例子——组装电脑，需要选择一系列的配件，为讨论使用简单点，只考虑选择CPU和主板的问题。</p><p>　　事实上，在选择CPU的时候，面临一系列的问题，比如品牌、型号、针脚数目、主频等问题，只有把这些问题都确定下来，才能确定具体的CPU。</p><p>　　同样，在选择主板的时候，也有一系列问题，比如品牌、芯片组、集成芯片、总线频率等问题，也只有这些都确定了，才能确定具体的主板。</p><p>　　在最终确定这个装机方案之前，还需要整体考虑各个配件之间的兼容性。比如：CPU和主板，如果使用Intel的CPU和AMD的主板是根本无法组装的。因为Intel的CPU针脚数与AMD主板提供的CPU插口不兼容，就是说如果使用Intel的CPU根本就插不到AMD的主板中，所以装机方案是整体性的，里面选择的各个配件之间是有关联的。</p><p>　　对于装机工程师而言，他只知道组装一台电脑，需要相应的配件，但是具体使用什么样的配件，还得由客户说了算。也就是说装机工程师只是负责组装，而客户负责选择装配所需要的具体的配件。因此，当装机工程师为不同的客户组装电脑时，只需要根据客户的装机方案，去获取相应的配件，然后组装即可。</p><h4 id="简单工厂模式的解决方案"><a href="#简单工厂模式的解决方案" class="headerlink" title="简单工厂模式的解决方案"></a>简单工厂模式的解决方案</h4><p>考虑客户的功能，需要选择自己需要的CPU和主板，然后告诉装机工程师自己的选择，接下来就等着装机工程师组装电脑了。<br>对装机工程师而言，只是知道CPU和主板的接口，而不知道具体实现，很明显可以用上简单工厂模式或工厂方法模式。为了简单，这里选用简单工厂。客户告诉装机工程师自己的选择，然后装机工程师会通过相应的工厂去获取相应的实例对象。</p><p><img src="/images/abstract_factory_simple_factory.png"></p><p>CPU接口与实现类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Cpu</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">calculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IntelCpu</span> <span class="token keyword">implements</span> <span class="token class-name">Cpu</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**CPU的针脚数*/</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> pins <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span>  <span class="token class-name">IntelCpu</span><span class="token punctuation">(</span><span class="token keyword">int</span> pins<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pins <span class="token operator">=</span> pins<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">calculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// TODO Auto-generated method stub</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Intel CPU的针脚数："</span> <span class="token operator">+</span> pins<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AmdCpu</span> <span class="token keyword">implements</span> <span class="token class-name">Cpu</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> pins <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">public</span>  <span class="token class-name">AmdCpu</span><span class="token punctuation">(</span><span class="token keyword">int</span> pins<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pins <span class="token operator">=</span> pins<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">calculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// TODO Auto-generated method stub</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"AMD CPU的针脚数："</span> <span class="token operator">+</span> pins<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主板接口与具体实现</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Mainboard</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">installCPU</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IntelMainboard</span> <span class="token keyword">implements</span> <span class="token class-name">Mainboard</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * CPU插槽的孔数     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> cpuHoles <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 构造方法，传入CPU插槽的孔数     * @param cpuHoles     */</span>    <span class="token keyword">public</span> <span class="token class-name">IntelMainboard</span><span class="token punctuation">(</span><span class="token keyword">int</span> cpuHoles<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>cpuHoles <span class="token operator">=</span> cpuHoles<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">installCPU</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// TODO Auto-generated method stub</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Intel主板的CPU插槽孔数是："</span> <span class="token operator">+</span> cpuHoles<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AmdMainboard</span> <span class="token keyword">implements</span> <span class="token class-name">Mainboard</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * CPU插槽的孔数     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> cpuHoles <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 构造方法，传入CPU插槽的孔数     * @param cpuHoles     */</span>    <span class="token keyword">public</span> <span class="token class-name">AmdMainboard</span><span class="token punctuation">(</span><span class="token keyword">int</span> cpuHoles<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>cpuHoles <span class="token operator">=</span> cpuHoles<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">installCPU</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// TODO Auto-generated method stub</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"AMD主板的CPU插槽孔数是："</span> <span class="token operator">+</span> cpuHoles<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>CPU与主板工厂类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CpuFactory</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Cpu</span> <span class="token function">createCpu</span><span class="token punctuation">(</span><span class="token keyword">int</span> type<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Cpu</span> cpu <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cpu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntelCpu</span><span class="token punctuation">(</span><span class="token number">755</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            cpu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AmdCpu</span><span class="token punctuation">(</span><span class="token number">938</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> cpu<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainboardFactory</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Mainboard</span> <span class="token function">createMainboard</span><span class="token punctuation">(</span><span class="token keyword">int</span> type<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Mainboard</span> mainboard <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            mainboard <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntelMainboard</span><span class="token punctuation">(</span><span class="token number">755</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            mainboard <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AmdMainboard</span><span class="token punctuation">(</span><span class="token number">938</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> mainboard<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>装机工程师类与客户类运行结果如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ComputerEngineer</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 定义组装机需要的CPU     */</span>    <span class="token keyword">private</span> <span class="token class-name">Cpu</span> cpu <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 定义组装机需要的主板     */</span>    <span class="token keyword">private</span> <span class="token class-name">Mainboard</span> mainboard <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">makeComputer</span><span class="token punctuation">(</span><span class="token keyword">int</span> cpuType <span class="token punctuation">,</span> <span class="token keyword">int</span> mainboard<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">/**         * 组装机器的基本步骤         */</span>        <span class="token comment">//1:首先准备好装机所需要的配件</span>        <span class="token function">prepareHardwares</span><span class="token punctuation">(</span>cpuType<span class="token punctuation">,</span> mainboard<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2:组装机器</span>        <span class="token comment">//3:测试机器</span>        <span class="token comment">//4：交付客户</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">prepareHardwares</span><span class="token punctuation">(</span><span class="token keyword">int</span> cpuType <span class="token punctuation">,</span> <span class="token keyword">int</span> mainboard<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//这里要去准备CPU和主板的具体实现，为了示例简单，这里只准备这两个</span>        <span class="token comment">//可是，装机工程师并不知道如何去创建，怎么办呢？</span>                <span class="token comment">//直接找相应的工厂获取</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>cpu <span class="token operator">=</span> <span class="token class-name">CpuFactory</span><span class="token punctuation">.</span><span class="token function">createCpu</span><span class="token punctuation">(</span>cpuType<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mainboard <span class="token operator">=</span> <span class="token class-name">MainboardFactory</span><span class="token punctuation">.</span><span class="token function">createMainboard</span><span class="token punctuation">(</span>mainboard<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//测试配件是否好用</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>cpu<span class="token punctuation">.</span><span class="token function">calculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mainboard<span class="token punctuation">.</span><span class="token function">installCPU</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的实现，虽然通过简单工厂方法解决了：对于装机工程师，只知CPU和主板的接口，而不知道具体实现的问题。但还有一个问题没有解决，那就是这些CPU对象和主板对象其实是有关系的，需要相互匹配的。而上面的实现中，并没有维护这种关联关系，CPU和主板是由客户任意选择，这是有问题的。比如在客户端调用makeComputer时，传入参数为(1,2)，客户选择的是Intel的CPU针脚数为755，而选择的主板是AMD，主板上的CPU插孔是938，根本无法组装，这就是没有维护配件之间的关系造成的。该怎么解决这个问题呢？　</p><h4 id="引进抽象工厂模式解决"><a href="#引进抽象工厂模式解决" class="headerlink" title="引进抽象工厂模式解决"></a>引进抽象工厂模式解决</h4><p>抽象工厂模式与工厂方法模式的最大区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则需要面对多个产品等级结构。</p><p>两个重要的概念：产品族和产品等级</p><ul><li>产品族：指位于不同产品等级结构中，功能相关联的产品组成的家族。比如AMD的主板、芯片组、CPU组成一个家族，Intel的主板、芯片组、CPU组成一个家族。而这两个家族都来自于三个产品等级：主板、芯片组、CPU。</li></ul><p><img src="/images/product_and_level.png"></p><p>上面所给出的三个不同的等级结构具有平行的结构。因此，如果采用工厂方法模式，势必要使用三个独立的工厂等级结构来对付这三个产品等级结构。由于这三个产品等级结构的相似性，会导致三个平行的工厂等级结构。随着产品等级结构的数目的增加，工厂方法模式所给出的工厂等级结构的数目也会随之增加。如下图：</p><p><img src="/images/product_level_multi_factory.png"></p><p>是否可以使用同一个工厂等级结构来对付这些相同或者极为相似的产品等级结构呢？当然可以的，而且这就是抽象工厂模式的好处。同一个工厂等级结构负责三个不同产品等级结构中的产品对象的创建。</p><p><img src="/images/product_level_multi_factory_abstract_factory.png"></p><p>可以看出，一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象。显然，这时候抽象工厂模式比简单工厂模式、工厂方法模式更有效率。对应于每一个产品族都有一个具体工厂。而每一个具体工厂负责创建属于同一个产品族，但是分属于不同等级结构的产品。</p><p><img src="/images/abstract_factory_class_uml.png"></p><p>前面示例实现的CPU接口和CPU实现对象，主板接口和主板实现对象，都不需要变化。<br>前面示例中创建CPU的简单工厂和创建主板的简单工厂，都不再需要。<br>新加入的抽象工厂类和实现类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 创建CPU对象     * @return CPU对象     */</span>    <span class="token keyword">public</span> <span class="token class-name">Cpu</span> <span class="token function">createCpu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 创建主板对象     * @return 主板对象     */</span>    <span class="token keyword">public</span> <span class="token class-name">Mainboard</span> <span class="token function">createMainboard</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IntelFactory</span> <span class="token keyword">implements</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Cpu</span> <span class="token function">createCpu</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// TODO Auto-generated method stub</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">IntelCpu</span><span class="token punctuation">(</span><span class="token number">755</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Mainboard</span> <span class="token function">createMainboard</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// TODO Auto-generated method stub</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">IntelMainboard</span><span class="token punctuation">(</span><span class="token number">755</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AmdFactory</span> <span class="token keyword">implements</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Cpu</span> <span class="token function">createCpu</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// TODO Auto-generated method stub</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">IntelCpu</span><span class="token punctuation">(</span><span class="token number">938</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Mainboard</span> <span class="token function">createMainboard</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// TODO Auto-generated method stub</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">IntelMainboard</span><span class="token punctuation">(</span><span class="token number">938</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>装机工程师类跟前面的实现相比，主要的变化是：从客户端不再传入选择CPU和主板的参数，而是直接传入客户已经选择好的产品对象。这样就避免了单独去选择CPU和主板所带来的兼容性问题，客户要选就是一套，就是一个系列。<br> <pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ComputerEngineer</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 定义组装机需要的CPU     */</span>    <span class="token keyword">private</span> <span class="token class-name">Cpu</span> cpu <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 定义组装机需要的主板     */</span>    <span class="token keyword">private</span> <span class="token class-name">Mainboard</span> mainboard <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">makeComputer</span><span class="token punctuation">(</span><span class="token class-name">AbstractFactory</span> af<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">/**         * 组装机器的基本步骤         */</span>        <span class="token comment">//1:首先准备好装机所需要的配件</span>        <span class="token function">prepareHardwares</span><span class="token punctuation">(</span>af<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2:组装机器</span>        <span class="token comment">//3:测试机器</span>        <span class="token comment">//4：交付客户</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">prepareHardwares</span><span class="token punctuation">(</span><span class="token class-name">AbstractFactory</span> af<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//这里要去准备CPU和主板的具体实现，为了示例简单，这里只准备这两个</span>        <span class="token comment">//可是，装机工程师并不知道如何去创建，怎么办呢？</span>                <span class="token comment">//直接找相应的工厂获取</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>cpu <span class="token operator">=</span> af<span class="token punctuation">.</span><span class="token function">createCpu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mainboard <span class="token operator">=</span> af<span class="token punctuation">.</span><span class="token function">createMainboard</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//测试配件是否好用</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>cpu<span class="token punctuation">.</span><span class="token function">calculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mainboard<span class="token punctuation">.</span><span class="token function">installCPU</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>抽象工厂的功能是为一系列相关对象或相互依赖的对象创建一个接口。一定要注意，这个接口内的方法不是任意堆砌的，而是一系列相关或相互依赖的方法。比如上面例子中的主板和CPU，都是为了组装一台电脑的相关对象。不同的装机方案，代表一种具体的电脑系列。</p><h4 id="在什么情况下应当使用抽象工厂模式"><a href="#在什么情况下应当使用抽象工厂模式" class="headerlink" title="在什么情况下应当使用抽象工厂模式"></a>在什么情况下应当使用抽象工厂模式</h4><ol><li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有形态的工厂模式都是重要的。</li><li>这个系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</li><li>同属于同一个产品族的产品是在一起使用的，这一约束必须在系统的设计中体现出来。（比如：Intel主板必须使用Intel CPU、Intel芯片组）</li><li>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现。</li></ol><h4 id="抽象工厂模式的优点"><a href="#抽象工厂模式的优点" class="headerlink" title="抽象工厂模式的优点"></a>抽象工厂模式的优点</h4><ul><li>分离接口和实现<br>  客户端使用抽象工厂来创建需要的对象，而客户端根本就不知道具体的实现是谁，客户端只是面向产品的接口编程而已。也就是说，客户端从具体的产品实现中解耦。</li><li>使切换产品族变得容易</li></ul><h4 id="抽象工厂模式的缺点"><a href="#抽象工厂模式的缺点" class="headerlink" title="抽象工厂模式的缺点"></a>抽象工厂模式的缺点</h4><ul><li>不太容易扩展新的产品<br>  如果需要给整个产品族添加一个新的产品，那么就需要修改抽象工厂，这样就会导致修改所有的工厂实现类。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桥接模式</title>
      <link href="/2021/03/16/she-ji-mo-shi/bridge/"/>
      <url>/2021/03/16/she-ji-mo-shi/bridge/</url>
      
        <content type="html"><![CDATA[<p>桥梁模式是对象的结构模式。又称为柄体(Handle and Body)模式或接口(Interface)模式。桥梁模式的用意是“将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化”。</p><ul><li><p>抽象化<br>从众多的事物中抽取出共同的、本质性的特征，而舍弃其非本质的特征，就是抽象化。共同特征是指那些能把一类事物与他类事物区分开来的特征，这些具有区分作用的特征又称本质特征。在抽象时，同与不同，决定于从什么角度上来抽象。抽象的角度取决于分析问题的目的。</p></li><li><p>实现化<br>抽象化给出的具体实现，就是实现化。</p></li><li><p>脱耦<br>所谓耦合，就是两个实体的行为的某种强关联。脱耦是指将它们之间的强关联改换成弱关联。 强关联，就是在编译时期已经确定的，无法在运行时期动态改变的关联；所谓弱关联，就是可以动态地确定并且可以在运行时期动态地改变的关联。显然，在Java语言中，继承关系是强关联，而聚合关系是弱关联。因此，桥梁模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用聚合关系而不是继承关系。</p></li></ul><p><img src="/images/bridge_01.png"></p><p>可以看出，这个系统含有两个等级结构：</p><ol><li>由抽象化角色和修正抽象化角色组成的抽象化等级结构。</li><li>由实现化角色和两个具体实现化角色所组成的实现化等级结构。</li></ol><p>桥梁模式所涉及的角色有：</p><ul><li>抽象化(Abstraction)角色：抽象化给出的定义，并保存一个对实现化对象的引用。</li><li>修正抽象化(RefinedAbstraction)角色：扩展抽象化角色，改变和修正父类对抽象化的定义。</li><li>实现化(Implementor)角色：这个角色给出实现化角色的接口，但不给出具体的实现。必须指出的是，这个接口不一定和抽象化角色的接口定义相同，实际上，这两个接口可以非常不一样。实现化角色应当只给出底层操作，而抽象化角色应当只给出基于底层操作的更高一层的操作。</li><li>具体实现化(ConcreteImplementor)角色：这个角色给出实现化角色接口的具体实现。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 抽象化角色类</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Abstraction</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">protected</span> <span class="token class-name">Implementor</span> impl<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Abstraction</span><span class="token punctuation">(</span><span class="token class-name">Implementor</span> impl<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>impl <span class="token operator">=</span> impl<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//示例方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                impl<span class="token punctuation">.</span><span class="token function">operationImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 修正抽象化角色</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RefinedAbstraction</span> <span class="token keyword">extends</span> <span class="token class-name">Abstraction</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">RefinedAbstraction</span><span class="token punctuation">(</span><span class="token class-name">Implementor</span> impl<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>impl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">//其他的操作方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">otherOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 实现化角色</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Implementor</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 示例方法，实现抽象部分需要的某些具体功能     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">operationImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 具体实现化角色</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteImplementorA</span> <span class="token keyword">extends</span> <span class="token class-name">Implementor</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operationImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//具体操作</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteImplementorB</span> <span class="token keyword">extends</span> <span class="token class-name">Implementor</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operationImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//具体操作</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式</title>
      <link href="/2021/03/16/she-ji-mo-shi/adapter/"/>
      <url>/2021/03/16/she-ji-mo-shi/adapter/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。 适配器模式有类的适配器模式和对象的适配器模式两种不同的形式。</p><h2 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h2><p>类的适配器模式把适配的类的API转换成为目标类的API。</p><p><img src="/images/adaptor_01.png"></p><p>在上图中可以看出，Adaptee类并没有sampleOperation2()方法，而客户端则期待这个方法。为使客户端能够使用Adaptee类，提供一个中间环节，即类Adapter，把Adaptee的API与Target类的API衔接起来。Adapter与Adaptee是继承关系，这决定了这个适配器模式是类的：</p><p>模式所涉及的角色有：</p><ul><li>目标(Target)角色：这就是所期待得到的接口。注意：由于这里讨论的是类适配器模式，因此目标不可以是类。</li><li>源(Adaptee)角色：现在需要适配的接口。</li><li>适配器(Adapter)角色：适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。</li></ul><p>示例代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Target</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sampleOperation1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sampleOperation2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Adaptee</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sampleOperation1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Adapter</span> <span class="token keyword">extends</span> <span class="token class-name">Adaptee</span> <span class="token keyword">implements</span> <span class="token class-name">Target</span> <span class="token punctuation">&#123;</span>  <span class="token comment">/**   * 由于源类Adaptee没有方法sampleOperation2()   * 因此适配器补充上这个方法   */</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sampleOperation2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//写相关的代码</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h2><p>与类的适配器模式一样，对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类。</p><p><img src="/images/adaptor_02.png"></p><p>示例代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Target</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sampleOperation1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sampleOperation2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Adaptee</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sampleOperation1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Adapter</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span> <span class="token class-name">Adaptee</span> adaptee<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token class-name">Adapter</span><span class="token punctuation">(</span><span class="token class-name">Adaptee</span> adaptee<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>adaptee <span class="token operator">=</span> adaptee<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sampleOperation1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>adaptee<span class="token punctuation">.</span><span class="token function">sampleOperation1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sampleOperation2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//写相关的代码</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="类适配器和对象适配器的权衡"><a href="#类适配器和对象适配器的权衡" class="headerlink" title="类适配器和对象适配器的权衡"></a>类适配器和对象适配器的权衡</h2><ol><li>类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。</li><li>对于类适配器，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作。</li><li>对于对象适配器，一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器可以把源类和它的子类都适配到目标接口。</li><li>对于类适配器，适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。</li><li>对于对象适配器，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。</li><li>对于类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。 对于对象适配器，需要额外的引用来间接得到Adaptee。</li></ol><blockquote><p>建议尽量使用对象适配器的实现方式，多用合成/聚合、少用继承。当然，具体问题具体分析，根据需要来选用实现方式，最适合的才是最好的。</p></blockquote><h2 id="适配器模式的优点"><a href="#适配器模式的优点" class="headerlink" title="适配器模式的优点"></a>适配器模式的优点</h2><ul><li>更好的复用性<br>系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。</li><li>更好的扩展性<br>在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。</li></ul><h2 id="适配器模式的缺点"><a href="#适配器模式的缺点" class="headerlink" title="适配器模式的缺点"></a>适配器模式的缺点</h2><p>过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建造模式</title>
      <link href="/2021/03/16/she-ji-mo-shi/builder/"/>
      <url>/2021/03/16/she-ji-mo-shi/builder/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>建造模式是对象的创建模式。建造模式可以将一个产品的内部表象（internal representation）与产品的生产过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。</p><ul><li><p>产品的内部表象<br>一个产品常有不同的组成成分，这些组成单元有可能是对象，也有可能不是对象，它们通常又叫做产品的内部表象。使用建造模式可以使客户端不需要知道所生成的产品有哪些零件，每个产品的对应零件彼此有何不同，是怎么建造出来的，以及怎么组成产品。</p></li><li><p>对象性质的建造<br>有些情况下，一个对象会有一些重要的性质，在它们没有恰当的值之前，对象不能作为一个完整的产品使用。有些情况下，一个对象的一些性质必须按照某个顺序赋值才有意义。在某个性质没有赋值之前，另一个性质则无法赋值。这些情况使得性质本身的建造涉及到复杂的商业逻辑。这时候，此对象相当于一个有待建造的产品，而对象的这些性质相当于产品的零件，建造产品的过程是建造零件的过程。由于建造零件的过程很复杂，因此，这些零件的建造过程往往被“外部化”到另一个称做建造者的对象里，建造者对象返还给客户端的是一个全部零件都建造完毕的产品对象。</p></li></ul><p>建造模式利用一个导演者对象和具体建造者对象一个个地建造出所有的零件，从而建造出完整的产品对象。建造者模式将产品的结构和产品的零件的建造过程对客户端隐藏起来，把对建造过程进行指挥的责任和具体建造者零件的责任分割开来，达到责任划分和封装的目的。</p><p><img src="/images/builder_01.png"></p><p>本模式涉及到四个角色，它们分别是：</p><ul><li><p>抽象建造者（Builder）角色：给 出一个抽象接口，以规范产品对象的各个组成成分的建造。一般而言，此接口独立于应用程序的商业逻辑。模式中直接创建产品对象的是具体建造者 (ConcreteBuilder)角色。具体建造者类必须实现这个接口所要求的两种方法：一种是建造方法(buildPart1和 buildPart2)，另一种是返还结构方法(retrieveResult)。一般来说，产品所包含的零件数目与建造方法的数目相符。换言之，有多少 零件，就有多少相应的建造方法。</p></li><li><p>具体建造者（ConcreteBuilder）角色：担任这个角色的是与应用程序紧密相关的一些类，它们在应用程序调用下创建产品的实例。这个角色要完成的任务包括：1.实现抽象建造者Builder所声明的接口，给出一步一步地完成创建产品实例的操作。2.在建造过程完成后，提供产品的实例。</p></li><li><p>导演者（Director）角色：担任这个角色的类调用具体建造者角色以创建产品对象。应当指出的是，导演者角色并没有产品类的具体知识，真正拥有产品类的具体知识的是具体建造者角色。</p></li><li><p>产品（Product）角色：产品便是建造中的复杂对象。一般来说，一个系统中会有多于一个的产品类，而且这些产品类并不一定有共同的接口，而完全可以是不相关联的。</p></li></ul><p>伪代码如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Product</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> part1<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> part2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Builder</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildPart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildPart2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Product</span> <span class="token function">retrieveResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteBuilder</span> <span class="token keyword">implements</span> <span class="token class-name">Builder</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Product</span> product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Product</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildPart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 　　　　product<span class="token punctuation">.</span><span class="token function">setPart1</span><span class="token punctuation">(</span><span class="token string">"编号"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildPart2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 　　　　product<span class="token punctuation">.</span><span class="token function">setPart2</span><span class="token punctuation">(</span><span class="token string">"名称"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Product</span> <span class="token function">retrieveResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> product<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Director</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">Builder</span> builder<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Director</span><span class="token punctuation">(</span><span class="token class-name">Builder</span> builder<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>builder <span class="token operator">=</span> builder<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        builder<span class="token punctuation">.</span><span class="token function">buildPart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">buildPart2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Client</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span>args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Builder</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Director</span> director <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Director</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span>        director<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Product</span> product <span class="token operator">=</span> builder<span class="token punctuation">.</span><span class="token function">retrieveResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>product<span class="token punctuation">.</span><span class="token function">getPart1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>product<span class="token punctuation">.</span><span class="token function">getPart2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端负责创建导演者和具体建造者对象。然后，客户端把具体建造者对象交给导演者，导演者操作具体建造者，开始创建产品。当产品完成后，建造者把产品返还给客户端。把创建具体建造者对象的任务交给客户端而不是导演者对象，是为了将导演者对象与具体建造者对象的耦合变成动态的，从而使导演者对象可以操纵数个具体建造者对象中的任何一个。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>假设有一个电子杂志系统，定期地向用户的电子邮件信箱发送电子杂志。用户可以通过网页订阅或结束订阅。当客户开始订阅时，系统发送一个电子邮件表示欢迎，当客户结束订阅时，系统发送一个电子邮件表示欢送。本例子就是这个系统负责发送“欢迎”和“欢送”邮件的模块。</p><p><img src="/images/builder_02.png"></p><p>这个系统含有客户端（Client）、导演者（Director）、抽象建造者（Builder）、具体建造者（WelcomeBuilder和GoodbyeBuilder）、产品（WelcomeMessage和GoodbyeMessage）等角色。</p><p>建造模式可以应用到具有完全不同接口的产品类上。大多数情况下是不知道最终构建出来的产品是什么样的，所以在标准的建造模式里面，一般是不需要对产品定义抽象接口的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Director</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Builder</span> builder<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Director</span><span class="token punctuation">(</span><span class="token class-name">Builder</span> builder<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>builder <span class="token operator">=</span> builder<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">construct</span><span class="token punctuation">(</span><span class="token class-name">String</span> toAddress <span class="token punctuation">,</span> <span class="token class-name">String</span> fromAddress<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>builder<span class="token punctuation">.</span><span class="token function">buildTo</span><span class="token punctuation">(</span>toAddress<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>builder<span class="token punctuation">.</span><span class="token function">buildFrom</span><span class="token punctuation">(</span>fromAddress<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>builder<span class="token punctuation">.</span><span class="token function">buildSubject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>builder<span class="token punctuation">.</span><span class="token function">buildBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>builder<span class="token punctuation">.</span><span class="token function">buildSendDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>builder<span class="token punctuation">.</span><span class="token function">sendMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// TODO Auto-generated method stub</span> 　　　　<span class="token class-name">Builder</span> builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WelcomeBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Director</span> director <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Director</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span>        director<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span><span class="token string">"toAddress@126.com"</span><span class="token punctuation">,</span> <span class="token string">"fromAddress@126.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>建造模式分成两个很重要的部分：</p><ul><li><ol><li>一个部分是Builder接口，也就是知道每个部件功能如何实现，以及如何装配这些部件到产品中去；</li></ol></li><li><ol start="2"><li>另外一个部分是Director，Director知道如何组合来构建产品，也就是说Director负责整体的构建算法，而且通常是分步骤地来执行。</li></ol></li></ul><p>在建造模式中，强调的是固定整体构建的算法，而灵活扩展和切换部件的具体构造和产品装配的方式。建造模式的重心在于分离构建算法和具体的构造实现，从而使得构建算法可以重用。具体的构造实现可以很方便地扩展和切换，从而可以灵活地组合来构造出不同的产品对象。</p><h2 id="使用建造模式构建复杂对象"><a href="#使用建造模式构建复杂对象" class="headerlink" title="使用建造模式构建复杂对象"></a>使用建造模式构建复杂对象</h2><p>考虑这样一个实际应用，要创建一个保险合同的对象，里面很多属性的值都有约束，要求创建出来的对象是满足这些约束规则的。约束规则比如：保险合同通常情况下可以和个人签订，也可以和某个公司签订，但是一份保险合同不能同时与个人和公司签订。</p><p>通常会对建造模式进行一定的简化，因为目标明确，就是创建某个复杂对象，因此做适当简化会使程序更简洁。大致简化如下：</p><ul><li>由于是用Builder模式来创建某个对象，因此就没有必要再定义一个Builder接口，直接提供一个具体的建造者类就可以了。</li><li>对于创建一个复杂的对象，可能会有很多种不同的选择和步骤，干脆去掉“导演者”，把导演者的功能和Client的功能合并起来，也就是说,Client这个时候就相当于导演者，它来指导构建器类去构建需要的复杂对象。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InsuranceContract</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//保险合同编号</span> 　　<span class="token keyword">private</span> <span class="token class-name">String</span> contractId<span class="token punctuation">;</span>    <span class="token comment">/**     * 被保险人员的名称，同一份保险合同，要么跟人员签订，要么跟公司签订     * 也就是说，“被保险人员”和“被保险公司”这两个属性，不可能同时有值     */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> personName<span class="token punctuation">;</span>    <span class="token comment">//被保险公司的名称</span> 　　<span class="token keyword">private</span> <span class="token class-name">String</span> companyName<span class="token punctuation">;</span>    <span class="token comment">//保险开始生效日期</span> 　　<span class="token keyword">private</span> <span class="token keyword">long</span> beginDate<span class="token punctuation">;</span>    <span class="token comment">//保险失效日期，一定会大于保险开始生效日期</span> 　　<span class="token keyword">private</span> <span class="token keyword">long</span> endDate<span class="token punctuation">;</span>    <span class="token comment">//其他数据</span> 　　<span class="token keyword">private</span> <span class="token class-name">String</span> otherData<span class="token punctuation">;</span>    <span class="token comment">//私有构造方法</span> 　　<span class="token keyword">private</span> <span class="token class-name">InsuranceContract</span><span class="token punctuation">(</span><span class="token class-name">ConcreteBuilder</span> builder<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>contractId <span class="token operator">=</span> builder<span class="token punctuation">.</span>contractId<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>personName <span class="token operator">=</span> builder<span class="token punctuation">.</span>personName<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>companyName <span class="token operator">=</span> builder<span class="token punctuation">.</span>companyName<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>beginDate <span class="token operator">=</span> builder<span class="token punctuation">.</span>beginDate<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>endDate <span class="token operator">=</span> builder<span class="token punctuation">.</span>endDate<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>otherData <span class="token operator">=</span> builder<span class="token punctuation">.</span>otherData<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 保险合同的一些操作     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">someOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前正在操作的保险合同编号为【"</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>contractId<span class="token operator">+</span><span class="token string">"】"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteBuilder</span><span class="token punctuation">&#123;</span>        <span class="token keyword">private</span> <span class="token class-name">String</span> contractId<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token class-name">String</span> personName<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token class-name">String</span> companyName<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">long</span> beginDate<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">long</span> endDate<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token class-name">String</span> otherData<span class="token punctuation">;</span>        <span class="token comment">/**         * 构造方法，传入必须要有的参数         * @param contractId     保险合同编号         * @param beginDate        保险合同开始生效日期         * @param endDate        保险合同失效日期         */</span>        <span class="token keyword">public</span> <span class="token class-name">ConcreteBuilder</span><span class="token punctuation">(</span><span class="token class-name">String</span> contractId<span class="token punctuation">,</span><span class="token keyword">long</span> beginDate<span class="token punctuation">,</span><span class="token keyword">long</span> endDate<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>contractId <span class="token operator">=</span> contractId<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>beginDate <span class="token operator">=</span> beginDate<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>endDate <span class="token operator">=</span> endDate<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//被保险人员的名称</span> 　　　　<span class="token keyword">public</span> <span class="token class-name">ConcreteBuilder</span> <span class="token function">setPersonName</span><span class="token punctuation">(</span><span class="token class-name">String</span> personName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>personName <span class="token operator">=</span> personName<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//被保险公司的名称</span> 　　　　<span class="token keyword">public</span> <span class="token class-name">ConcreteBuilder</span> <span class="token function">setCompanyName</span><span class="token punctuation">(</span><span class="token class-name">String</span> companyName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>companyName <span class="token operator">=</span> companyName<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//其他数据</span> 　　　　<span class="token keyword">public</span> <span class="token class-name">ConcreteBuilder</span> <span class="token function">setOtherData</span><span class="token punctuation">(</span><span class="token class-name">String</span> otherData<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>otherData <span class="token operator">=</span> otherData<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">/**         * 构建真正的对象并返回         * @return    构建的保险合同对象         */</span>        <span class="token keyword">public</span> <span class="token class-name">InsuranceContract</span> <span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>contractId <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> contractId<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"合同编号不能为空"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">boolean</span> signPerson <span class="token operator">=</span> <span class="token punctuation">(</span>personName <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> personName<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">boolean</span> signCompany <span class="token operator">=</span> <span class="token punctuation">(</span>companyName <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> companyName<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>signPerson <span class="token operator">&amp;&amp;</span> signCompany<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"一份保险合同不能同时与个人和公司签订"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>signPerson <span class="token operator">==</span> <span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> signCompany <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"一份保险合同不能没有签订对象"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>beginDate <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"一份保险合同必须有开始生效的日期"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>endDate <span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"一份保险合同必须有失效的日期"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>endDate <span class="token operator">&lt;</span> beginDate<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"一份保险合同的失效日期必须大于生效日期"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">InsuranceContract</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span>args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//创建构建器对象</span> 　　　　<span class="token class-name">InsuranceContract<span class="token punctuation">.</span>ConcreteBuilder</span> builder <span class="token operator">=</span>            <span class="token keyword">new</span> <span class="token class-name">InsuranceContract<span class="token punctuation">.</span>ConcreteBuilder</span><span class="token punctuation">(</span><span class="token string">"9527"</span><span class="token punctuation">,</span> <span class="token number">123L</span><span class="token punctuation">,</span> <span class="token number">456L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//设置需要的数据，然后构建保险合同对象</span> 　　　　<span class="token class-name">InsuranceContract</span> contract <span class="token operator">=</span>             builder<span class="token punctuation">.</span><span class="token function">setPersonName</span><span class="token punctuation">(</span><span class="token string">"小明"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setOtherData</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//操作保险合同对象的方法</span> 　　　　contract<span class="token punctuation">.</span><span class="token function">someOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="在什么情况下使用建造模式"><a href="#在什么情况下使用建造模式" class="headerlink" title="在什么情况下使用建造模式"></a>在什么情况下使用建造模式</h2><ol><li>需要生成的产品对象有复杂的内部结构，每一个内部成分本身可以是对象，也可以仅仅是一个对象（即产品对象）的一个组成部分。</li><li>需要生成的产品对象的属性相互依赖。建造模式可以强制实行一种分步骤进行的建造过程，因此，如果产品对象的一个属性必须在另一个属性被赋值之后才可以被赋值，使用建造模式是一个很好的设计思想。</li><li>在对象创建过程中会使用到系统中的其他一些对象，这些对象在产品对象的创建过程中不易得到。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>备忘录模式</title>
      <link href="/2021/03/16/she-ji-mo-shi/memento/"/>
      <url>/2021/03/16/she-ji-mo-shi/memento/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型模式</title>
      <link href="/2021/03/16/she-ji-mo-shi/prototype/"/>
      <url>/2021/03/16/she-ji-mo-shi/prototype/</url>
      
        <content type="html"><![CDATA[<p>《JAVA与模式》一书的原型模式描述的： 原型模式属于对象的创建模式。通过给出一个原型对象来指明所有创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象。这就是选型模式的用意。</p><h2 id="原型模式的结构"><a href="#原型模式的结构" class="headerlink" title="原型模式的结构"></a>原型模式的结构</h2><p>原型模式要求对象实现一个可以“克隆”自身的接口，这样就可以通过复制一个实例对象本身来创建一个新的实例。这样一来，通过原型实例创建新的对象，就不再需要关心这个实例本身的类型，只要实现了克隆自身的方法，就可以通过这个方法来获取新的对象，而无须再去通过new来创建。</p><p>原型模式有两种表现形式：（1）简单形式、（2）登记形式，这两种表现形式仅仅是原型模式的不同实现。</p><h3 id="简单形式"><a href="#简单形式" class="headerlink" title="简单形式"></a>简单形式</h3><p><img src="/images/prototype_01.png"></p><p>这种形式涉及到三个角色：</p><ol><li>客户(Client)角色：客户类提出创建对象的请求。</li><li>抽象原型(Prototype)角色：这是一个抽象角色，通常由一个Java接口或Java抽象类实现。此角色给出所有的具体原型类所需的接口。</li><li>具体原型（Concrete Prototype）角色：被复制的对象。此角色需要实现抽象的原型角色所要求的接口。</li></ol><h3 id="登记形式"><a href="#登记形式" class="headerlink" title="登记形式"></a>登记形式</h3><p><img src="/images/prototype_02.png"></p><p>作为原型模式的第二种形式，它多了一个原型管理器(PrototypeManager)角色，该角色的作用是：创建具体原型类的对象，并记录每一个被创建的对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrototypeManager</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Prototype</span><span class="token punctuation">></span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Prototype</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">PrototypeManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">setPrototype</span><span class="token punctuation">(</span><span class="token class-name">String</span> prototypeId <span class="token punctuation">,</span> <span class="token class-name">Prototype</span> prototype<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>prototypeId<span class="token punctuation">,</span> prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">removePrototype</span><span class="token punctuation">(</span><span class="token class-name">String</span> prototypeId<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>prototypeId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 获取某个原型编号对应的原型实例     */</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token class-name">Prototype</span> <span class="token function">getPrototype</span><span class="token punctuation">(</span><span class="token class-name">String</span> prototypeId<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Prototype</span> prototype <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>prototypeId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>prototype <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"您希望获取的原型还没有注册或已被销毁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> prototype<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="两种形式的比较"><a href="#两种形式的比较" class="headerlink" title="两种形式的比较"></a>两种形式的比较</h3><p>如果需要创建的原型对象数目较少而且比较固定的话，可以采取第一种形式。在这种情况下，原型对象的引用可以由客户端自己保存。 如果要创建的原型对象数目不固定的话，可以采取第二种形式。</p><h2 id="Java中的克隆方法"><a href="#Java中的克隆方法" class="headerlink" title="Java中的克隆方法"></a>Java中的克隆方法</h2><p>Java的所有类都是从java.lang.Object类继承而来的，而Object类提供protected Object clone()方法对对象进行复制。对象的复制有一个基本问题，就是对象通常都有对其他的对象的引用。当使用Object类的clone()方法来复制一个对象时，此对象对其他对象的引用也同时会被复制一份</p><p>Java语言提供的Cloneable接口只起一个作用，就是在运行时期通知Java虚拟机可以安全地在这个类上使用clone()方法。通过调用这个clone()方法可以得到一个对象的复制。由于Object类本身并不实现Cloneable接口，因此如果所考虑的类没有实现Cloneable接口时，调用clone()方法会抛出CloneNotSupportedException异常。</p><h3 id="浅克隆和深克隆"><a href="#浅克隆和深克隆" class="headerlink" title="浅克隆和深克隆"></a>浅克隆和深克隆</h3><p>无论你是自己实现克隆方法，还是采用Java提供的克隆方法，都存在一个浅度克隆和深度克隆的问题。</p><ul><li><p>浅度克隆<br>只负责克隆按值传递的数据（比如基本数据类型、String类型），而不复制它所引用的对象，换言之，所有的对其他对象的引用都仍然指向原来的对象。</p></li><li><p>深度克隆<br>除了浅度克隆要克隆的值外，还负责克隆引用类型的数据。那些引用其他对象的变量将指向被复制过的新对象。 换言之，深度克隆把要复制的对象所引用的对象都复制了一遍，而这种对被引用到的对象的复制叫做间接复制。</p></li></ul><h3 id="序列化实现深度克隆"><a href="#序列化实现深度克隆" class="headerlink" title="序列化实现深度克隆"></a>序列化实现深度克隆</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span>  <span class="token class-name">Object</span> <span class="token function">deepClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">&#123;</span>       <span class="token comment">//将对象写到流里</span>       <span class="token class-name">ByteArrayOutputStream</span> bos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">ObjectOutputStream</span> oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>bos<span class="token punctuation">)</span><span class="token punctuation">;</span>       oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//从流里读回来</span>       <span class="token class-name">ByteArrayInputStream</span> bis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>bos<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">ObjectInputStream</span> ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>bis<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样做的前提就是对象以及对象内部所有引用到的对象都是可序列化的，否则，就需要仔细考察那些不可序列化的对象可否设成transient，从而将之排除在复制过程之外。 </p><h2 id="原型模式的优点"><a href="#原型模式的优点" class="headerlink" title="原型模式的优点"></a>原型模式的优点</h2><p>原型模式允许在运行时动态改变具体的实现类型。原型模式可以在运行期间，由客户来注册符合原型接口的实现类型，也可以动态地改变具体的实现类型，看起来接口没有任何变化，但其实运行的已经是另外一个类实例了。因为克隆一个原型就类似于实例化一个类。</p><h2 id="原型模式的缺点"><a href="#原型模式的缺点" class="headerlink" title="原型模式的缺点"></a>原型模式的缺点</h2><p>原型模式最主要的缺点是每一个类都必须配备一个克隆方法。配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类来说不是很难，而对于已经有的类不一定很容易，特别是当一个类引用不支持序列化的间接对象，或者引用含有循环结构的时候。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式</title>
      <link href="/2021/03/16/she-ji-mo-shi/strategy/"/>
      <url>/2021/03/16/she-ji-mo-shi/strategy/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>策略模式属于对象的行为模式。针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。</p><p><img src="/images/strategy_01.png"></p><p>这个模式涉及到三个角色：</p><ul><li><p>环境(Context)角色：持有一个Strategy的引用。</p></li><li><p>抽象策略(Strategy)角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</p></li><li><p>具体策略(ConcreteStrategy)角色：包装了相关的算法或行为。</p></li></ul><h2 id="认识策略模式"><a href="#认识策略模式" class="headerlink" title="认识策略模式"></a>认识策略模式</h2><h3 id="策略模式的重心"><a href="#策略模式的重心" class="headerlink" title="策略模式的重心"></a>策略模式的重心</h3><p>策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。</p><h3 id="算法的平等性"><a href="#算法的平等性" class="headerlink" title="算法的平等性"></a>算法的平等性</h3><p>策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以相互替换。所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的。</p><p>所以可以这样描述这一系列策略算法：策略算法是相同行为的不同实现。</p><h3 id="运行时策略的唯一性"><a href="#运行时策略的唯一性" class="headerlink" title="运行时策略的唯一性"></a>运行时策略的唯一性</h3><p>运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个。</p><h3 id="公有的行为"><a href="#公有的行为" class="headerlink" title="公有的行为"></a>公有的行为</h3><p>经常见到的是，所有的具体策略类都有一些公有的行为。这时候，就应当把这些公有的行为放到共同的抽象策略角色Strategy类里面。当然这时候抽象策略角色必须要用Java抽象类实现，而不能使用接口。</p><h2 id="策略模式的优点"><a href="#策略模式的优点" class="headerlink" title="策略模式的优点"></a>策略模式的优点</h2><p>（1）策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。</p><p>（2）使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。</p><h2 id="策略模式的缺点"><a href="#策略模式的缺点" class="headerlink" title="策略模式的缺点"></a>策略模式的缺点</h2><p>（1）客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。</p><p>（2）由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池</title>
      <link href="/2021/03/15/java/thread-pool/"/>
      <url>/2021/03/15/java/thread-pool/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>线程池的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大线程的数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>降低资源消耗。通过重复利用已经创建的线程降低线程创建和销毁的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可统一分配、调优和监控。</li></ul><h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><p>JDK1.5开始，Java提供了Executor框架来创建不同的线程池。该框架中用到Executor、Executors，ExecutorService、ThreadPoolExecutor这几个类,</p><p><img src="/images/threadpool-juc.png"></p><ol><li>Executor提供接口将任务提交和执行过程解耦，并用Runnable表示任务,Executor基于”生产者-消费者”模式，提交任务的操作相当于生产者，执行任务的则相当于消费者。<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Executor</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * Executes the given command at some time in the future.  The command     * may execute in a new thread, in a pooled thread, or in the calling     * thread, at the discretion of the &#123;@code Executor&#125; implementation.     *     * @param command the runnable task     * @throws RejectedExecutionException if this task cannot be     * accepted for execution     * @throws NullPointerException if command is null     */</span>    <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>ExecutorService 扩展了Executor接口，添加了一些生命周期管理的方法,</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ExecutorService</span> <span class="token keyword">extends</span> <span class="token class-name">Executor</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span> <span class="token function">shutdownNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">isTerminated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">awaitTermination</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">,</span> <span class="token class-name">T</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Future</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">invokeAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Callable</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span><span class="token punctuation">></span></span> tasks<span class="token punctuation">)</span>        <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="线程池核心构造"><a href="#线程池核心构造" class="headerlink" title="线程池核心构造"></a>线程池核心构造</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                          <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>                          <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span> workQueue<span class="token punctuation">,</span>                          <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span>                          <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>        maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span>        maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span>        keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> threadFactory <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> handler <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>corePoolSize： 线程池中的常驻核心线程数，默认情况下，线程池中没有任何线程（线程数为0），等有任务到来才创建线程去执行任务。当线程池中的线程数达到corePoolSize后，就会把到达的任务放到缓存队列中。没有任务执行时，线程池大小不一定时corePoolSize，allowCoreThreadTimeOut.</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Timeout in nanoseconds for idle threads waiting for work. * Threads use this timeout when there are more than corePoolSize * present or if allowCoreThreadTimeOut. Otherwise they wait * forever for new work. */</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">;</span><span class="token comment">/** * If false (default), core threads stay alive even when idle. * If true, core threads use keepAliveTime to time out waiting * for work. */</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> allowCoreThreadTimeOut<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>maximumPoolSize: 线程池中允许的最大线程数，线程池能够容纳的最大线程数，此值必须大于等于1。</p></li><li><p>keepAliveTime<br>空闲线程的存活时间。默认情况下，只有当线程池中的线程数大于corePoolSize时，这个参数才会起作用。当线程数大于corePoolSize时，当空闲时间达到keepAliveTime的值时，多余的空闲线程会被销毁直到只剩下corePoolSize。</p></li><li><p>unit: keepAliveTime时间单位</p></li><li><p>workQueue：任务队列，用来缓存已提交未执行的任务</p></li><li><p>threadFactory：生成线程池中工作线程的线程工厂</p></li><li><p>handler: 超出线程范围maximumPoolSize和workQueue队列容量时所使用的拒绝策略。 线程池类库自带4种拒绝策略。</p><ul><li>AbortPolicy-终止策略。直接抛出一个RejectedExecutionException，也是JDK默认的拒绝策略。</li><li>CallerRunsPolicy-调用者运行策略。将任务回退到调用者（让调用者执行）降低任务量。</li><li>DiscardOldestPolicy-抛弃最旧的策略。移除队列中最先进入的任务，并且尝试执行任务。</li><li>DiscardPolicy-抛弃策略。直接丢弃任务。<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><img src="/images/thread_pool_process.png"></li></ul></li></ul><p>工作流程：</p><ol><li>在创建线程池后，等待提交过来的任务请求。</li><li>当调用execute() 方法添加一个请求任务时，线程池会进行一系列判断：<ol><li>如果正在运行的线程数小于corePoolSize ，那么马上创建线程执行这个任务。</li><li>如果正在运行的线程数大于或等于corePoolSize，那么将这个任务放入队列。</li><li>如果队列满且正在运行的线程数小于maximumPoolSize，那么还是要创建非核心线程立即执行这个任务。</li><li>如果队列满且正在运行的线程数大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。</li></ol></li><li>当一个线程完成任务时，它会从队列中取下一个任务来执行。</li><li>当一个线程无事可做超过一定的单位（unit）时间（keepAliveTime）时，线程池会判断：<ol><li>如果当前运行的线程数大于corePoolSize，那么这个线程就会被销毁。</li><li>如果线程池的全部任务完成，线程池将会收缩到corePoolSize大小。allowCoreThreadTimeOut：true ，核心线程等待超时关闭。</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存屏障</title>
      <link href="/2021/03/13/jvm/memory-barrier/"/>
      <url>/2021/03/13/jvm/memory-barrier/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>内存屏障，就是让CPU处理单元中的内存状态对其他处理单元可见的技术，内存屏障提供了两个功能，首先通过确保从另一个处理核来看屏障两边的所以指令都是正确的程序顺序，保证程序顺序的外部可见性；其次可以实现内存数据的可见性，确保内存数据会同步到CPU缓存子系统。</p><h2 id="Store-Barrier"><a href="#Store-Barrier" class="headerlink" title="Store Barrier"></a>Store Barrier</h2><p>Store屏障，是x86的”sfence“指令，强制所有在store屏障指令之前的store指令，都在该store屏障指令执行之前被执行，并把store缓冲区的数据都刷到CPU缓存。这会使得程序状态对其它CPU可见，这样其它CPU可以根据需要介入。</p><h2 id="Load-Barrier"><a href="#Load-Barrier" class="headerlink" title="Load Barrier"></a>Load Barrier</h2><p>Load屏障，是x86上的”ifence“指令，强制所有在load屏障指令之后的load指令，都在该load屏障指令执行之后被执行，并且一直等到load缓冲区被该CPU读完才能执行之后的load指令。这使得从其它CPU暴露出来的程序状态对该CPU可见，这之后CPU可以进行后续处理。</p><h2 id="Full-Barrier"><a href="#Full-Barrier" class="headerlink" title="Full Barrier"></a>Full Barrier</h2><p>Full屏障，是x86上的”mfence“指令，复合了load和save屏障的功能。</p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>Java内存模型中volatile变量在写操作之后会插入一个store屏障，在读操作之前会插入一个load屏障。一个类的final字段会在初始化后插入一个store屏障，来确保final字段在构造函数初始化完成并可被使用时可见。</p><h2 id="原子指令和Software-Locks"><a href="#原子指令和Software-Locks" class="headerlink" title="原子指令和Software Locks"></a>原子指令和Software Locks</h2><p>原子指令，如x86上的”lock …” 指令是一个Full Barrier，执行时会锁住内存子系统来确保执行顺序，甚至跨多个CPU。Software Locks通常使用了内存屏障或原子指令来实现变量可见性和保持程序顺序。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Volatile</title>
      <link href="/2021/03/13/java/volatile/"/>
      <url>/2021/03/13/java/volatile/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Volatile可以说是虚拟机提供的最轻量的同步机制，Java内存模型也为其定义了特殊的访问规则。<br>两项特性：</p><ol><li><p>此关键字定义的变量对所以线程的可见性；<br>volatile变量在各线程的工作内存中不存在一致性问题（物理存储值可能不一致，但是每次使用前都要刷新，执行引擎看不到不一致情况）</p></li><li><p>禁止指令重排序优化<br> Java在保证“线程内表现为串行语义”的前提下对指令进行重排序优化</p><h2 id="线程的可见性"><a href="#线程的可见性" class="headerlink" title="线程的可见性"></a>线程的可见性</h2><p>Volatile变量在各个线程都是一致的，但是不能保证对此变量的操作都是线程安全的，Java里的运算符并非原子操作，如<code>ract++</code>反编译以后得到的结果是由4条字节码指令构成，这四条指令不能保证原子性，指令如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">0: getstatic3: iconst_14: iadd5: putstatic<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>即使编译出来的是一条字节码指令，也不意味者这条指令就是原子操作指令，字节码在解释执行时，解释器要多条代码才能实现它的语义，在编译执行时，也可能被转化成若干本地机器码。可以使用-XX:+PrintAssembly输出反汇编。</p></li></ol><p>不符合一下两条规则的场景，依然要通过加锁保证原子性</p><ul><li>运算结果不依赖变量当前值，或确保仅一个线程会对其进行修改；</li><li>变量不需要和其他状态变量一起参与不变约束</li></ul><p>适用场景举例，当shutdown被调用时，能保证所以线程中的doWork都停下来</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">volatile</span> <span class="token keyword">boolean</span> shutdownRe<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    shutdownRe <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>shutdownRe<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">// business code。。。</span>        <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="禁止指令重排序"><a href="#禁止指令重排序" class="headerlink" title="禁止指令重排序"></a>禁止指令重排序</h2><blockquote><p>volatile屏蔽指令重排序的语义在JDK5才被完全修复，即之前利用此机制实现的双锁检测实现单例模式依然不安全</p></blockquote><p>普通变量仅保证在执行过程中依赖其赋值的地方获取结果正确，而不保证变量赋值操作的顺序</p><p>可以通过HSDIS插件获取编译的汇编，通过比较可以发现volatile变量在赋值后紧跟了一条“Lock addl XXX”指令，其相当于一个内存屏障，强制所有在屏障指令之前的指令，都在该屏障指令执行之前被执行，并把缓冲区的数据写回主内存同时失效其他内核中该数据的缓存。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载机制</title>
      <link href="/2021/03/11/jvm/classloader/"/>
      <url>/2021/03/11/jvm/classloader/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Java虚拟机把描述类的Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可被虚拟机使用的Java类型，这个过程被称作虚拟机的类加载机制。</p><h2 id="加载时机"><a href="#加载时机" class="headerlink" title="加载时机"></a>加载时机</h2><p>一个类型从被加载到虚拟机内存开始到卸载出内存为止，这个生命周期要经历加载、验证、准备、解析、初始化、使用和卸载七个阶段，如下图<br><img src="/images/java_class_loader.png" alt="类的生命周期"><br>其中加载、验证、准备、初始化和卸载这五个阶段是顺序（开始的顺序，执行阶段可能会交叉）确定的。解析阶段则不一定，某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定特性。</p><p>对于初始化阶段，《Java虚拟机规范》严格规定了<strong>有且仅有</strong>六种情况下必须对类进行”初始化“</p><ol><li>遇到new、getstatic、putstatic、和invokestatic这四条字节码指令时<ul><li>new关键字实例化对象</li><li>读取和设置一个类型的静态字段（final修饰，已在编译器放入常量池的静态字段除外）</li><li>调用一个类型的静态方法</li></ul></li><li>使用反射对类型进行反射调用</li><li>初始化类时，如果父类还未初始化要先对父类进行初始化</li><li>虚拟机启动，用户需要指定要执行的主类</li><li>当使用JDK7新加入的动态语言支持时，如果<code>java.lang.invoke.MethHandle</code>实例最后的解析结果为REF_getStatic\REF_putStatic\REF_invokeStatic\REF_newInvokeSpecial四种类型的方法句柄</li><li>当一个接口中定义了JDK8新加入的默认方法，如果这个接口的实现类进行了初始化，那这个接口也要在之前进行初始化</li></ol><h2 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载阶段虚拟机需要完成三件事</p><ol><li>通过一个类的全限定名获取二进制字节流</li><li>将这个字节流代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的Class对象，最为方法区这个类的各种数据访问入口</li></ol><p>虚拟机规范对这三点要求并不特别具体，所以虚拟机实现的灵活度很大，”通过一个类的全限定名获取二进制字节流“衍生了很多技术</p><ul><li>从ZIP压缩包中读取，最终形成了JAR.EAR,WAR格式的基础</li><li>从网络中获取，典型的WebApplet</li><li>运行时计算生成，如动态代理技术</li><li>由其他文件生成， 典型场景JSP应用</li><li>从数据库读取</li><li>从加密文件中获取</li><li>…</li></ul><p>数组比较特殊，数组类本身不通过类加载器创建，是由Java虚拟机直接在内存中动态构造出阿里，但是数组类的元素类型最终还是要靠类加载器完成加载，一个数组类创建过程遵循一下规则：</p><ul><li>数组的元素类型是引用类型，递归加载这些引用类型，数组类被标识在加载数组元素类型的类加载器的类名空间上</li><li>如果数组元素不是引用类型，虚拟机将会把数组类标记为与引导类加载器关联</li><li>数组类的可访问性和它的元素类型的可访问性一致，如果元素类型不是引用类，那数组类的可访问性默认public，</li></ul><p>加载结束后，外部的二进制字节流就按照虚拟机设定的格式存储在方法区。类型数据放到方法区以后，会在Java堆内存中实例化一个Class类对象，这个类对象作为程序访问方法区的类型数据的外部入口。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证是连接的第一步，确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束。<br>大致分为四个阶段的检验动作：文件格式验证、元数据验证、字节码验证和符号引用验证</p><h4 id="1-文件格式验证"><a href="#1-文件格式验证" class="headerlink" title="1. 文件格式验证"></a>1. 文件格式验证</h4><p>该验证阶段的主要目的是保证输入的字节流能正确的解析并存储在方法区内，格式上符合一个类型信息的要求。此阶段基于二进制字节流进行，验证通过后字节流被允许进入方法区，所以后边的三个结算都是基于方法区的存储结构上进行，不用在读取和操作字节流。</p><p>验证点包含：</p><ul><li>是否以魔数0xCAFFEBABE开头</li><li>主、次版本号是否在范围内</li><li>常量池的常量是否由不被支持的常量类型</li><li>指向常量的各种索引值是否指向不存在的常量</li><li>…</li></ul><h4 id="2-元数据验证"><a href="#2-元数据验证" class="headerlink" title="2. 元数据验证"></a>2. 元数据验证</h4><p>对字节码描述的信息进行语义分析，保证其描述信息符合《Java语言规范》的要求，这个阶段可能包含的验证点如下</p><ul><li>这个类是否有父类（除了Object，其他都应该有父类）</li><li>这个类的父类是否继承了不被允许的类（final修饰）</li><li>如果不是抽象类，是否实现了父类或接口中的方法</li><li>…</li></ul><h4 id="3-字节码验证"><a href="#3-字节码验证" class="headerlink" title="3. 字节码验证"></a>3. 字节码验证</h4><p>字节码校验是整个验证过程最复杂的一个阶段，主要是通过数据流分析和控制流分析，确定程序语义的合法性，和逻辑性。这阶段主要是对类的方法体进行校验分析，保证类方法的安全，如：</p><ul><li>保证任意时刻，操作数栈的数据类型与指令代码序列都能配合工作</li><li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上</li><li>保证方法体内的类型转换总是有效的</li><li>…</li></ul><p>虚拟机设计团队为了避免在字节码验证阶段进行耗时过长的数据流和控制流分析，在JDK6之后的javac编译器和虚拟机里进行了一项联合优化，尽可能的把验证辅助措施挪到了javac编译器里进行，具体做法是</p><p>JDK6的Hotspot提供了-XX：-UseSplitVerifier来关闭这项优化，或则使用参数-XX:+FailOverToOldVerifier要求在类型校验失败时退回到旧的类型推导方式校验。到了JDK7以后，只能使用类型检查完成数据流分析校验。</p><h4 id="4-符号引用验证"><a href="#4-符号引用验证" class="headerlink" title="4. 符号引用验证"></a>4. 符号引用验证</h4><p>目的是确保解析行为正常进行，这一阶段的行为发生在虚拟机将符号引用转化为直接引用的时候，这个动作将在连接的第三个阶段-解析阶段发生。</p><p>可看作是对类自身以外的各类信息进行匹配性校验，即该类是否缺少或则被禁止访问它依赖的某些外部类，方法，字段等，本阶段主要验证：</p><ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类</li><li>指定类中是否存在符合方法的字段描述及简单名称所描述的方法和字段</li><li>符号引用中的类，字段，方法的可访问性是否可被当前类访问。</li><li>…</li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段会正式为类中定义的变量（静态变量）分配内存并设置类变量初始值（数据类型的零值）。JDK8及以后，类变量随着Class对象一起存放在堆内存中。</p><p>对于类型零值，如</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">124</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>变量value准备阶段以后的初始值为0，而不是124. 而124的赋值指令是程序被编译后，存放在类构造器<code>&lt;clinit&gt;()</code>方法中，所以要等到类的初始化阶段。各类型的零值如下</p><table><thead><tr><th>数据类型</th><th>零值</th><th>数据类型</th><th>零值</th></tr></thead><tbody><tr><td>int</td><td>0</td><td>boolean</td><td>false</td></tr><tr><td>long</td><td>0L</td><td>float</td><td>0.0f</td></tr><tr><td>short</td><td>(short)0</td><td>double</td><td>0.0D</td></tr><tr><td>char</td><td>‘\u0000’</td><td>reference</td><td>null</td></tr><tr><td>byte</td><td>(byte)0</td><td></td><td></td></tr></tbody></table><p>如果类字段的字段属性表中存在ConstantValue属性，在准备阶段变量值就会被初始化为ConstantValue</p><blockquote><p>public static <strong>final</strong> int value = 124</p></blockquote><p>Javac将会为value生产ConstantValue属性，在准备阶段就会将value设置为124.</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程</p><ul><li><p>符号引用<br>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时可以无歧义的定位到目标即可</p></li><li><p>直接引用<br>直接引用是可以直接指向目标的指针，相对偏移量或则一个能间接定位到目标的句柄。</p></li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段就是执行类构造器<clinit>()方法的过程，</p><ul><li><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块（static{}）中的语句合并而成，顺序是语句在源文件中的顺序。静态语句块中只能访问到定义在语句块之前的变量，定义其后的变量，可以赋值不能访问</li><li><code>&lt;clinit&gt;()</code>方法执行前先执行父类的此方法，所以父类的静态语句块也要先于子类执行</li><li><code>&lt;clinit&gt;()</code>方法对于类或接口不是必须的，如果没有静态代码块或则赋值，编译器也可以不生产此方法</li><li>接口中不能使用静态代码块，但是由变量初始化操作，因此接口和类一样都会有<code>&lt;clinit&gt;()</code>方法，但是不同的是接口执行时不需要先执行父类的<code>&lt;clinit&gt;()</code>方法，因为只有当父接口中定义的变量被使用时，父接口才会被实例化，此外接口的实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法。</li><li>虚拟机保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确的加锁同步，</li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每个类加载器都拥有一个独立的类名称空间。</p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>对于Java虚拟机来说，存在两种不同的类加载器，启动类加载器（C++编写）和其他所有的类加载器（Java编写，全部继承自java.lang.ClassLoader, 存在与虚拟机外部 ）</p><p>对于开发角度，分三大类</p><ul><li>启动类加载器</li><li>扩展类加载器</li><li>应用程序类加载器</li></ul><p>类加载器的“双亲委派模型”要求除了顶层的启动类加载器，其他的都应有自己的父类加载器，这里的父子关系是通过组合的方式来复用父类加载器的代码。</p><p>双亲委派模型的工作过程：一个类加载器收到加载类的请求，先将此请求转发给自己的父类加载完成，每一层都是如此，因此所有的请求都会从启动类加载器开始尝试加载，只有父类返回无法加载，子类加载器才会自己去完成。</p><h3 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h3><p>“双亲”模型不是强制约束的，而是推荐给我们的类加载是实现方式，到Java的模块化出现，出现过“被破坏”情况。</p><ol><li><p>双亲委派模型在引入之前已经存在破坏它的代码存在了。 双亲委派模型在 JDK 1.2 之后才被引入，而类加载器和抽象类 java.lang.ClassLoader 则在 JDK 1.0 时代就已经存在，JDK 1.2之后，其添加了一个新的 protected 方法 findClass()，在此之前，用户去继承 ClassLoader 类的唯一目的就是为了重写 loadClass() 方法，而双亲委派的具体逻辑就实现在这个方法之中，JDK 1.2 之后已不提倡用户再去覆盖 loadClass() 方法，而应当把自己的类加载逻辑写到 findClass() 方法中，这样就可以保证新写出来的类加载器是符合双亲委派规则的。</p></li><li><p>基础类无法调用类加载器加载用户提供的代码。 双亲委派很好地解决了各个类加载器的基础类的统一问题，但如果基础类又要调用用户的代码，例如 JNDI 服务，JNDI现在已经是 Java 的标准服务，它的代码由启动类加载器去加载（在 JDK 1.3 时放进去的 rt.jar ），但JNDI需要调用由独立厂商实现并部署在应用程序的 ClassPath 下的 JNDI 接口提供者（SPI，例如JDBC驱动就是由 MySQL 等接口提供者提供的）的代码，但启动类加载器只能加载基础类，无法加载用户类。</p><blockquote><p>为此 Java 引入了线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过 java.lang.Thread.setContextClassLoaser() 方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。<br>如此，JNDI 服务使用这个线程上下文类加载器去加载所需要的 SPI 代码，也就是父类加载器请求子类加载器去完成类加载的动作。</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JIT - 逃逸分析</title>
      <link href="/2021/03/11/jvm/jit-escape-analysis/"/>
      <url>/2021/03/11/jvm/jit-escape-analysis/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>逃逸分析，与类型继承关系分析一样，并不是直接优化代码的手段，而是为其他优化措施提供依据的分析技术。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>分析对象的动态作用域，在方法体中被定义的变量可能被外部方法所引用，如作为调用参数传递到其他方法中，这种称为方法逃逸。 甚至可能被外部线程访问到，如赋值给可以在其他线程中访问的实例变量，这种称为线程逃逸。从不逃逸、方法逃逸到线程逃逸，称为对象由高到低的逃逸程度。</p><h2 id="优化手段"><a href="#优化手段" class="headerlink" title="优化手段"></a>优化手段</h2><p>逃逸程度不同，可以有不同的优化手段</p><h3 id="栈山分配（Stack-Allocations）："><a href="#栈山分配（Stack-Allocations）：" class="headerlink" title="栈山分配（Stack Allocations）："></a><strong>栈山分配（Stack Allocations）</strong>：</h3><p>对于不会逃逸出线程之外的对象，可以在栈上分配内存，对象所占的内存空间随栈帧出栈而销毁，也会减轻垃圾回收的压力。栈上分配可以支持方法逃逸，但是不能支持线程逃逸。</p><h3 id="标量替换（Scalar-Replacement）："><a href="#标量替换（Scalar-Replacement）：" class="headerlink" title="标量替换（Scalar Replacement）："></a><strong>标量替换（Scalar Replacement）</strong>：</h3><p>一个数据无法分解成更小的数据来表示，Java虚拟机中的原始数据类型（基本类型和Reference类型）都不能再分解，这些数据就称为标量。如果可以继续分解就称为聚合量（Aggregate），如Java对象。</p><p>原理: 如果把一个对象拆散，根据程序访问的情况，将其用到的成员变量恢复为原始类型访问，这个过程就叫标量替换</p><p>对象不会被方法外部访问（不会方法逃逸），且可被拆散，那程序执行时不会真正的创建这个对象，改为创建被使用的成员变量来代码，除了可以让对象的成员变量在栈上，还可以为进一步的优化创造条件。</p><h3 id="同步消除（Synchronization-Elimination）："><a href="#同步消除（Synchronization-Elimination）：" class="headerlink" title="同步消除（Synchronization Elimination）："></a><strong>同步消除（Synchronization Elimination）</strong>：</h3><p>如果逃逸分析能够确定不会发生线程逃逸，那这个变量就不存在竞争，可以安全的消除同步措施</p><blockquote><p>JDK6,Hotspot才开始支持初步的逃逸分析，到现在仍不成熟，主要原因是逃逸分析的成本非常高，如果要完全准确判断一个对象是否逃逸，需要一系列复制的数据流敏感的过程间分析。目前虚拟机采用不那么准确的时间压力相对较小的算法完成分析。</p><p>由于逃逸分析的成本和准确率，在JDK7才默认开启，-XX: +DoEscapeAnalysis 可调，开启以后可通过-XX:+PrintEscapeAnalysis查看分析结果，有了逃逸分析可通过参数-XX：EliminateAllocations开启标量替换，使用-XX:+EliminateLocks开启同步消除，使用-XX:+PrintEliminateAllocations查看标量替换的结果</p></blockquote><h2 id="逃逸分析的流程示例"><a href="#逃逸分析的流程示例" class="headerlink" title="逃逸分析的流程示例"></a>逃逸分析的流程示例</h2><p>初始代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> xx <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token class-name">Point</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span>xx<span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第一步，将Point构造函数和getX（）方法进行内联优化</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> xx <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token class-name">Point</span> p <span class="token operator">=</span> <span class="token function">point_memory_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 堆上分配p</span>        p<span class="token punctuation">.</span>x <span class="token operator">=</span> xx<span class="token punctuation">;</span> <span class="token comment">// 构造方法被内联</span>        p<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">.</span>x<span class="token punctuation">;</span> <span class="token comment">// Point::getX 方法被内联</span>        <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二步，逃逸分析,发现不会方法逃逸，进行标量替换</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> xx <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> px <span class="token operator">=</span> xx<span class="token punctuation">;</span>    <span class="token keyword">int</span> py <span class="token operator">=</span> <span class="token number">42</span>    <span class="token keyword">return</span> py<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数据量分析，进行无用代码消除</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型</title>
      <link href="/2021/03/11/jvm/java-memory-model/"/>
      <url>/2021/03/11/jvm/java-memory-model/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PossibleReordering</span> <span class="token punctuation">&#123;</span><span class="token keyword">static</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Thread</span> one <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            x <span class="token operator">=</span> b<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Thread</span> other <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            y <span class="token operator">=</span> a<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    one<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>other<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    one<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>other<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>“<span class="token punctuation">(</span>” <span class="token operator">+</span> x <span class="token operator">+</span> “<span class="token punctuation">,</span>” <span class="token operator">+</span> y <span class="token operator">+</span> “<span class="token punctuation">)</span>”<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很容易想到这段代码的运行结果可能为(1,0)、(0,1)或(1,1)，因为线程one可以在线程two开始之前就执行完了，也有可能反之，甚至有可能二者的指令是同时或交替执行的。</p><p>然而，这段代码的执行结果也可能是(0,0). 因为，在实际运行时，代码指令可能并不是严格按照代码语句顺序执行的。得到(0,0)结果的语句执行过程。（事实上，输出了这一结果，并不代表一定发生了指令重排序，内存可见性问题也会导致这样的输出，详见后文）</p><p>大多数现代微处理器都会采用将指令乱序执行（out-of-order execution，简称OoOE或OOE）的方法，在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据时造成的等待3。通过乱序执行的技术，处理器可以大大提高执行效率。</p><p>除了处理器，常见的Java运行时环境的JIT编译器也会做指令重排序操作4，即生成的机器指令与字节码指令顺序不一致。</p><h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h3><p>As-if-serial语义的意思是，所有的动作(Action)都可为了优化而被重排序，但是必须保证它们重排序后的结果和程序代码本身的应有结果是一致的。Java编译器、运行时和处理器都会保证<strong>单线程下</strong>的as-if-serial语义。 </p><p>比如，为了保证这一语义，重排序不会发生在有数据依赖的操作之中。</p><ul><li>int a = 1;</li><li>int b = 2;</li><li>int c = a + b;<br>将上面的代码编译成Java字节码或生成机器指令，可视为展开成了以下几步动作（实际可能会省略或添加某些步骤）。</li><li>对a赋值1</li><li>对b赋值2</li><li>取a的值</li><li>取b的值<br>将取到两个值相加后存入c<br>在上面5个动作中，动作1可能会和动作2、4重排序，动作2可能会和动作1、3重排序，动作3可能会和动作2、4重排序，动作4可能会和1、3重排序。但动作1和动作3、5不能重排序。动作2和动作4、5不能重排序。因为它们之间存在数据依赖关系，一旦重排，as-if-serial语义便无法保证。</li></ul><p>为保证as-if-serial语义，Java异常处理机制也会为重排序做一些处理。如在下面的代码中，y = 0 / 0可能会被重排序在x = 2之前执行，为了保证最终不致于输出x = 1的错误结果，JIT在重排序时会在catch语句中插入错误代偿代码，将x赋值为2，将程序恢复到发生异常时应有的状态。这种做法的确将异常捕捉的逻辑变得复杂了，但是JIT的优化的原则是，尽力优化正常运行下的代码逻辑，哪怕以catch块逻辑变得复杂为代价，毕竟，进入catch块内是一种“异常”情况的表现。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Reordering</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>        x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>            y <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"x = "</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="内存访问重排序与Java内存模型"><a href="#内存访问重排序与Java内存模型" class="headerlink" title="内存访问重排序与Java内存模型"></a>内存访问重排序与Java内存模型</h3><p>Java的目标是成为一门平台无关性的语言，但是不同硬件环境下指令重排序的规则不尽相同。例如，x86下运行正常的Java程序在IA64下就可能得到非预期的运行结果。为此，JSR-1337制定了Java内存模型(Java Memory Model, JMM)，旨在提供一个统一的可参考的规范，屏蔽平台差异性。从Java 5开始，Java内存模型成为Java语言规范的一部分。</p><p>根据Java内存模型中的规定，可以总结出以下几条happens-before规则。Happens-before的前后两个操作不会被重排序且后者对前者的内存可见。</p><ul><li>程序次序法则：线程中的每个动作A都happens-before于该线程中的每一个动作B，其中，在程序中，所有的动作B都能出现在A之后。</li><li>监视器锁法则：对一个监视器锁的解锁 happens-before于每一个后续对同一监视器锁的加锁。</li><li>volatile变量法则：对volatile域的写入操作happens-before于每一个后续对同一个域的读写操作。</li><li>线程启动法则：在一个线程里，对Thread.start的调用会happens-before于每个启动线程的动作。</li><li>线程终结法则：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结、或者从Thread.join调用中成功返回，或Thread.isAlive返回false。</li><li>中断法则：一个线程调用另一个线程的interrupt happens-before于被中断的线程发现中断。</li><li>终结法则：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。</li><li>传递性：如果A happens-before于B，且B happens-before于C，则A happens-before于C</li></ul>]]></content>
      
      
      <categories>
          
          <category> 虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JIT - 方法内联</title>
      <link href="/2021/03/10/jvm/jit-method-inner/"/>
      <url>/2021/03/10/jvm/jit-method-inner/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>先通过一段代码，体会编译优化的手段</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 原始代码</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">&#123;</span>       <span class="token keyword">int</span> value<span class="token punctuation">;</span>       <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           <span class="token keyword">return</span> value<span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       y <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// ... do stuff...</span>       z <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       sum <span class="token operator">=</span> y <span class="token operator">+</span> z<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法内联的主要目的有两个</p><ul><li>去除方法调用的成本（查找方法版本，建立栈帧等）</li><li>为其他优化建立良好的基础</li></ul><p>方法内联膨胀以后可以更大范围进行后续优化，因此各编译器也会优先进行方法内联，上述代码内联后的代码如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 方法内联</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    y <span class="token operator">=</span> b<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token comment">// ... do stuff...</span>    z <span class="token operator">=</span> b<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    sum <span class="token operator">=</span> y <span class="token operator">+</span> z<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一步进行了冗余访问消除，而如果中间代码不会改变<code>b.get()</code>的值，那么<code>z = b.value</code>可以直接替换称<code>z = y</code>，即为公共子表达式消除，优化以后的代码如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 公共子表达式消除</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    y <span class="token operator">=</span> b<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token comment">// ... do stuff...</span>    z <span class="token operator">=</span> y<span class="token punctuation">;</span>    sum <span class="token operator">=</span> y <span class="token operator">+</span> z<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一步可以看到没有使用z变量，它与<code>y</code>变量相等，因此可以采用复写传播，代码如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 复写传播</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    y <span class="token operator">=</span> b<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token comment">// ... do stuff...</span>    y <span class="token operator">=</span> y<span class="token punctuation">;</span>    sum <span class="token operator">=</span> y <span class="token operator">+</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再进行无用代码消除，无用代码是可能永远不会被执行的代码，也可能是完全没有意义的代码，优化如下</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 无用代码消除</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    y <span class="token operator">=</span> b<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token comment">// ... do stuff...</span>    sum <span class="token operator">=</span> y <span class="token operator">+</span> y<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h2><p>方法内联，就是在编译过程中遇到方法调用时，将目标方法纳入到编译范围内，并取代原方法调用的编译优化手段</p><p>内联优化的示例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">int</span>  <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b <span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">add</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>内联之后,明显减少了二次调用函数带来的函数调用开销</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">int</span>  <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b <span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">add</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="方法内联条件"><a href="#方法内联条件" class="headerlink" title="方法内联条件"></a>方法内联条件</h2><p>对于即时编译器来说，内联越多，编译时间就越长，且生成的机器码也越长。在JVM里，编译生成的机器码都被放到Code Cache中，这个区域是有大小限制的（XX:ReservedCodeCacheSize可调）。</p><p>所以方法内联不能无限制进行，需要满足特定条件</p><ul><li>由 -XX:CompileCommand中的inline指令指定的方法和由@ForceInline（此注解仅限于JDK的内部方法）注解的方法，会被强制内联；对应的，由-XX:CompileCommand中的dontinline指令或者exclude指令指定的方法和由@DontInline注解的方法，则始终不会被内联。</li><li>如果调用字节码对应的符号引用未被解析、目标方法所在的类未初始化、目标方法是native方法，都将导致该方法无法内联。</li><li>C2不支持内联超过9层的调用（-XX:MaxInlineLivel可调）以及一层的直接递归调用（-XX:MaxRecursiveInlineLevel可调）</li><li>JIT将根据方法调用指令所在程序的路径的热度，目标方法的调用次数（-XX:CompileThreshold可调）和大小以及当前IR图的代销来决定方法调用能否内联。</li></ul><p>来自《深入理解Java虚拟机》一书</p><blockquote><p>只有使用<code>invokespecial</code>指令调用的私有方法、实例构造器、父类方法和使用<code>invokestatic</code>指令调用的静态方法才会在编译器进行解析（最多除去被final修饰的方法，尽管它使用invokevirtual指令，但也是非虚方法），其他Java方法都必须在运行时进行方法接收者的多态选择，简而言之，Java中的默认的实例方法都是虚方法。</p></blockquote><h2 id="去虚化"><a href="#去虚化" class="headerlink" title="去虚化"></a>去虚化</h2><p>对于静态方法，JIT可以明确目标方法，但是对于需要动态绑定的虚方法调用，就需要对其进行去虚化，去虚化分为<strong>完全去虚化</strong>和<strong>条件去虚化</strong>。</p><h3 id="完全去虚化"><a href="#完全去虚化" class="headerlink" title="完全去虚化"></a>完全去虚化</h3><p>完全去虚化是通过类型推到或者类层次分析（CHA），识别虚方法调用的唯一目标方法，从而转换为直接调用的优化手段，它的关键在于证明虚方法调用的目标方法是唯一的。</p><ul><li>基于类型推导的完全去虚化将通过数据流分析推到出调用者的动态类型，从而确定具体的目标方法。</li><li>基于类层次分析的完全去虚化是通过分析Java虚拟机中所有已被加载的类，判断某个抽象方法或者接口方法是否仅有一个实现。</li></ul><p>JVM的为当前编译结果注册若干个假设，假设某抽象类只有一个子类，或某类没有子类等类似假设。在这之后，每当新的类被加载，JVM就会重新验证这些假设项，如果某个假设不再成立，那么JVM就会对其所属的编译结果进行去优化，退到解释执行的状态。事实上，即使方法是一个子类方法，即时编译器仍需为其添加假设，这是因为JVM并不能保证没有重写了方法的下级子类。所以，对于一些没有扩展子类必要的类，我们可以加上final关键字，这样JVM就不会再为其增加子类相关的假设，减少类加载时所需的验证内容。</p><p>如果向CHA查询出来的结果确实存在多个版本的目标方法，即使编译器还会尝试使用<strong>内联缓存（InlineCache）</strong>的方式缩减开销，</p><p>内联缓存是建立在目标方法正常入口之前的缓存，工作原理大致：</p><p>未调用，内联缓存状态为空，第一次调用，缓存记录下方法接受者的版本信息并每次调用都比较接收者版本，如果后续的版本信息都是一样的，这是就是<strong>单态内联缓存（Monomorphic Inline Cache）</strong>。</p><p>通过该缓存调用比用不内联的非虚方法调用仅多了一次类型判断的开销而已，但是如果真的虚方法的多态性，就退化成<strong>超多态内联缓存（Megamorphic Inline Cache）</strong>，其开销相当于真正查找虚方法表来进行方法分派。</p><h3 id="条件去虚化"><a href="#条件去虚化" class="headerlink" title="条件去虚化"></a>条件去虚化</h3><p>条件去虚化是通过向代码中添加若干个类型比较，将虚方法调用转换为若干个直接调用。即将调用者的动态类型，依次与JVM所搜集的类型Profile中记录的类型作比较，如果匹配，则直接调用该记录类型所对应的目标方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">BinaryOp</span> op<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> op<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>假设编译时类型Profile记录了调用者的两个类型Sub和Add，那么即时编译器可以根据此条件去虚化，依次比较调用者的动态类型是否为Sub或者Add，并内联相应的方法。如下是伪代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token class-name">BinaryOp</span> op<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>op<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">Sub</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// inlined Sub.apply</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>op<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token class-name">Add</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// inlined Add.apply</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// 当匹配不到类型Profile中的类型怎么办？</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>遍历类型Profile未匹配到调用者的动态类型，那么即时编译器有两种选择</p><ul><li>类型Profile是完整的，也就是说，所有出现过的动态类型都被记录到类型Profile中了，那么即时编译器可以让程序去优化，重新收集类型Profile。</li><li>类型Profile是不完整的，也就是指某些出现过的动态类型未被记录到类型Profile中，那么重新收集也没有特别的作用，此时，即时编译器可以让程序进行原本的虚调用，通过内联缓存进行调用或者通过方法表进行动态绑定。（在C2中，如果类型Profile是不完整的，即时编译器不会进行条件去虚化，而是直接使用内联缓存或者方法表）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例设计模式</title>
      <link href="/2021/03/10/she-ji-mo-shi/singleton-design/"/>
      <url>/2021/03/10/she-ji-mo-shi/singleton-design/</url>
      
        <content type="html"><![CDATA[<h2 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h2><p>单例模式：一个类有且仅有一个实例</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingleTon</span><span class="token punctuation">&#123;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">SingleTon</span> singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingleTon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token class-name">SingleTon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">SingleTon</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> singleton<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="懒汉式（线程不安全）"><a href="#懒汉式（线程不安全）" class="headerlink" title="懒汉式（线程不安全）"></a>懒汉式（<strong>线程不安全</strong>）</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleSingleTon</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">SimpleSingleTon</span> singleton <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">SimpleSingleTon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">SimpleSingleTon</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleSingleTon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>加入同步改造，依然线程不安全，由于指令重排的问题，可能导致其他线程获取到未进行初始化的实例对象.</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleSingleTon</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">SimpleSingleTon</span> singleton <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">SimpleSingleTon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span>  <span class="token class-name">SimpleSingleTon</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">SimpleSingleTon</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleSingleTon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>双重检测方案：使用<code>volatile</code>的内存屏障禁止指令重排序,</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleSingleTon</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">SimpleSingleTon</span> singleton <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">SimpleSingleTon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span>  <span class="token class-name">SimpleSingleTon</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">SimpleSingleTon</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleSingleTon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>             <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleSingleTon</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">SimpleSingleTon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">LazySingleTon</span><span class="token punctuation">&#123;</span>        <span class="token keyword">private</span> <span class="token keyword">static</span>  <span class="token keyword">final</span>  <span class="token class-name">SimpleSingleTon</span> INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleSingleTon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">SimpleSingleTon</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       <span class="token keyword">return</span> <span class="token class-name">LazySingleTon</span><span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Type</span> <span class="token punctuation">&#123;</span>    HIGH<span class="token punctuation">,</span>    LOW<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过<code>javap -c Type.class</code></p><pre class="line-numbers language-text" data-language="text"><code class="language-text">public final class com.web.mvc.test.Type extends java.lang.Enum&lt;com.web.mvc.test.Type&gt; &#123;  public static final com.web.mvc.test.Type HIGH;  public static final com.web.mvc.test.Type LOW;  public static com.web.mvc.test.Type[] values();    Code:       0: getstatic     #1                  &#x2F;&#x2F; Field $VALUES:[Lcom&#x2F;web&#x2F;mvc&#x2F;test&#x2F;Type;       3: invokevirtual #2                  &#x2F;&#x2F; Method &quot;[Lcom&#x2F;web&#x2F;mvc&#x2F;test&#x2F;Type;&quot;.clone:()Ljava&#x2F;lang&#x2F;Object;       6: checkcast     #3                  &#x2F;&#x2F; class &quot;[Lcom&#x2F;web&#x2F;mvc&#x2F;test&#x2F;Type;&quot;       9: areturn  public static com.web.mvc.test.Type valueOf(java.lang.String);    Code:       0: ldc           #4                  &#x2F;&#x2F; class com&#x2F;web&#x2F;mvc&#x2F;test&#x2F;Type       2: aload_0       3: invokestatic  #5                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Enum.valueOf:(Ljava&#x2F;lang&#x2F;Class;Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;Enum;       6: checkcast     #4                  &#x2F;&#x2F; class com&#x2F;web&#x2F;mvc&#x2F;test&#x2F;Type       9: areturn  static &#123;&#125;;    Code:       0: new           #4                  &#x2F;&#x2F; class com&#x2F;web&#x2F;mvc&#x2F;test&#x2F;Type       3: dup       4: ldc           #7                  &#x2F;&#x2F; String HIGH       6: iconst_0       7: invokespecial #8                  &#x2F;&#x2F; Method &quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;String;I)V      10: putstatic     #9                  &#x2F;&#x2F; Field HIGH:Lcom&#x2F;web&#x2F;mvc&#x2F;test&#x2F;Type;      13: new           #4                  &#x2F;&#x2F; class com&#x2F;web&#x2F;mvc&#x2F;test&#x2F;Type      16: dup      17: ldc           #10                 &#x2F;&#x2F; String LOW      19: iconst_1      20: invokespecial #8                  &#x2F;&#x2F; Method &quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;String;I)V      23: putstatic     #11                 &#x2F;&#x2F; Field LOW:Lcom&#x2F;web&#x2F;mvc&#x2F;test&#x2F;Type;      26: iconst_2      27: anewarray     #4                  &#x2F;&#x2F; class com&#x2F;web&#x2F;mvc&#x2F;test&#x2F;Type      30: dup      31: iconst_0      32: getstatic     #9                  &#x2F;&#x2F; Field HIGH:Lcom&#x2F;web&#x2F;mvc&#x2F;test&#x2F;Type;      35: aastore      36: dup      37: iconst_1      38: getstatic     #11                 &#x2F;&#x2F; Field LOW:Lcom&#x2F;web&#x2F;mvc&#x2F;test&#x2F;Type;      41: aastore      42: putstatic     #1                  &#x2F;&#x2F; Field $VALUES:[Lcom&#x2F;web&#x2F;mvc&#x2F;test&#x2F;Type;      45: return&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见枚举类也是通过静态特性帮助进行初始化属性值</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Synchronized</title>
      <link href="/2021/03/09/java/synchronized/"/>
      <url>/2021/03/09/java/synchronized/</url>
      
        <content type="html"><![CDATA[<h2 id="Synchronized-介绍"><a href="#Synchronized-介绍" class="headerlink" title="Synchronized 介绍"></a>Synchronized 介绍</h2><p>Java提供了两种实现同步的基础语义：synchronized方法和synchronized块</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SyncTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">syncBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello block"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">syncMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 <code>javap -v</code> 查看class文件和字节码信息</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">public void syncBlock();        descriptor: ()V        flags: ACC_PUBLIC        Code:        stack&#x3D;2, locals&#x3D;3, args_size&#x3D;1        0: aload_0        1: dup        2: astore_1        3: monitorenter        &#x2F;&#x2F; monitorenter指令进入同步块        4: getstatic     #2                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;        7: ldc           #3                  &#x2F;&#x2F; String hello block        9: invokevirtual #4                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V        12: aload_1        13: monitorexit        &#x2F;&#x2F; monitorexit指令退出同步块        14: goto          22        17: astore_2        18: aload_1        19: monitorexit        &#x2F;&#x2F; monitorexit指令退出同步块        20: aload_2        21: athrow        22: return        Exception table:        from    to  target type        4    14    17   any        17    20    17   anypublic synchronized void syncMethod();        descriptor: ()V        flags: ACC_PUBLIC, ACC_SYNCHRONIZED      &#x2F;&#x2F;添加了ACC_SYNCHRONIZED标记        Code:        stack&#x3D;2, locals&#x3D;1, args_size&#x3D;1        0: getstatic     #2                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;        3: ldc           #5                  &#x2F;&#x2F; String hello method        5: invokevirtual #4                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V        8: return<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于synchronized关键字而言，javac在编译时，会生成对应的monitorenter和monitorexit指令分别对应synchronized同步块的进入和退出，有两个monitorexit指令的原因是：为了保证抛异常的情况下也能释放锁，所以javac为同步代码块添加了一个隐式的try-finally，在finally中会调用monitorexit命令释放锁。</p><p>对于synchronized方法而言，javac为其生成了一个ACCSYNCHRONIZED关键字，在JVM进行方法调用时，发现调用的方法被ACCSYNCHRONIZED修饰，则会先尝试获得锁。</p><h2 id="Synchronized-锁优化"><a href="#Synchronized-锁优化" class="headerlink" title="Synchronized 锁优化"></a>Synchronized 锁优化</h2><p>传统的锁依赖系统的同步函数，在Linux上使用mutex互斥量，最底层实现依赖futex，这些同步函数都涉及到用户态和内核态的切换，进程上下文切换，成本较高。对于加了synchronized关键字但运行时并没有多线程竞争，或两个线程接近于交替执行的情况，使用传统锁机制无疑效率是会比较低的。在JDK 1.6之前,synchronized只有传统的锁机制，因此给开发者留下了synchronized关键字相比于其他同步机制性能不好的印象。</p><p>在JDK1.6引入了两种新型锁机制：偏向锁和轻量级锁，它们的引入是为了解决在没有多线程竞争或基本没有竞争的场景下因使用传统锁机制带来的性能开销问题。</p><p>在看这几种锁机制的实现前，我们先来了解下对象头，它是实现多种锁机制的基础。</p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>Hotspot虚拟机中的对象头分为两部分，第一部分存储对象自身的运行数据，如哈希码，GC分代年龄等，长度在32和64位虚拟机中分别占32和64个比特，官方称位<code>Mark Work</code>。另一部分存储指向方法区对象类型数据的指针，如果是数组对象还会额外存储数组对象长度，由于对象头信息是与对象自身数据无关的额外成本，考虑到Java虚拟机的空间使用效率，Mark Work被设计成一个非固定的动态数据结构。在32位系统上各状态的格式如下：<br><img src="/images/object_header.png" alt="对象头"></p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁JDK6加入，并不是为了替代重量级锁，设计初衷是为了在没有多线程竞争的情况下，减少传统重量级锁使用操作系统互斥量产生的性能损耗</p><h4 id="加锁："><a href="#加锁：" class="headerlink" title="加锁："></a>加锁：</h4><p>在代码即将进入同步块时，判断同步对象是否被锁住（锁标志位”01”）,虚拟机首先在栈帧中创建锁记录”Lock Record“空间，用于存储锁对象的”MarkWord“拷贝（Displaced Mark Work），然后使用CAS操作把<strong>锁对象的MarkWork</strong>更新为指向<strong>LockRecord</strong>的指针。更新成功，代表该线程持有了锁，，且对象<code>MarkWord</code>的锁标志位变成“00”，表示此对象出于轻量级锁状态。更新失败，表示有线程竞争该锁，虚拟机先检查对象<code>MarkWord</code>是否指向当前线程栈帧，不是当前线程，判定为出现多线程竞争锁的情况，那轻量级锁不再有效，需要膨胀为重量级锁，锁标志位变为“10”，此时<code>MarkWork </code>存储指向重量级锁的指针，等待锁的线程进入阻塞状态。</p><h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><p>解锁过程同样使用CAS，如果锁对象的<code>MarkWork</code>依然指向线程的<code>LockRecord</code>, 使用CAS将锁对象当前的<code>MarkWork</code>和线程中复制的<code>Displaced Mark Work</code>做替换，如果成功，同步结束，失败则说明有其他线程尝试获取过该锁，释放锁的同时唤醒被挂起的线程。</p><p><strong>轻量级锁提升性能的场景为，绝大部分锁，同步周期内都是不存在竞争的，如果存在竞争，除了互斥量开销，还额外发生CAS操作，因此在高并发竞争下，轻量级锁反而比传统锁更慢。</strong></p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁JDK6加入，目的是为了消除数据在无竞争情况下的同步原语，进一步提升性能，如果说轻量级锁是在无竞争情况下使用CAS操作消除同步使用的互斥量，那偏向锁就是在无竞争的情况下去掉同步语义。可以通过<code>-XX:-UseBiasedLocking</code>禁止偏向锁优化</p><h4 id="加锁：-1"><a href="#加锁：-1" class="headerlink" title="加锁："></a>加锁：</h4><p>如果虚拟机启用了偏向锁（-XX:+UseBiasedLocking,JKD6以后虚拟机的默认值）。<br>锁对象第一次被线程获取时，虚拟机会把对象头中的标识位设置为”01“，偏向模式设置”1“，进入偏向模式，同时使用CAS操作把获取到锁的线程ID记录到锁对象的<code>MarkWork</code>中，CAS成功，持有偏向锁的线程以后每次进入同步块，虚拟机都不再进行任何同步操作，</p><h4 id="解锁-1"><a href="#解锁-1" class="headerlink" title="解锁"></a>解锁</h4><p>一旦有另外一个线程去尝试获取这个锁，偏向模式马上结束，根据对象释放出于被锁定状态决定是否撤销偏向锁（偏向模式设置”0“），撤销以后标志位恢复到未锁定（标志位”01“）或轻量级锁定（标志位”00“）状态。</p><p><strong>偏向锁需要保持线程ID，HashCode怎么存放呢？</strong><br>在Java中一个对象如果计算过hashCode，就应该保持这个值不变，因此当一个对象计算过哈希码后就再也无法进入偏向锁状态，而一个对象如果正出于偏向锁状态，又收到需要计算一致性哈希码的需求，它的偏向锁会立即撤销并且锁会膨胀为重量级锁。在重量级锁的实现中，对象头指向了重量级锁的位置，说明重量级锁ObjectMontor类里有可以记录非加锁状态（标志位”01“）的<code>MarkWork</code>信息。</p><h3 id="锁消除和锁粗化"><a href="#锁消除和锁粗化" class="headerlink" title="锁消除和锁粗化"></a>锁消除和锁粗化</h3><p>除了对同步原语的锁机制优化，还提供了锁粒度自动优化，帮忙优化锁的滥用。</p><h4 id="消除"><a href="#消除" class="headerlink" title="消除"></a>消除</h4><p>即时编译器运行时，对代码要求同步，但是检测到不可能存在共享数据竞争的锁进行消除。<br>其主要判定依据源于逃逸分析的数据支持，一段代码中，堆上的数据不会逃逸出去被其他线程访问到，就可以把他们都当作栈上数据对待，同步自然不需要存在。除了优化开发人员的同步语义还有许多同步并不是开发人员加入。例如每个JDK5以后的字符串拼接自动转到使用<code>StringBuffer.append()</code>，它的每个方法都有一个同步块，锁就是SB对象，</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">concatString</span><span class="token punctuation">(</span><span class="token class-name">String</span> a<span class="token punctuation">,</span> <span class="token class-name">String</span> b<span class="token punctuation">,</span> <span class="token class-name">String</span> c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">StirngBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>经过逃逸分析，sb对象作用域限制在方法内，可以进行锁消除优化，即可忽略同步措施。</p><h4 id="粗化"><a href="#粗化" class="headerlink" title="粗化"></a>粗化</h4><p>代码编写过程中总要求尽量缩小同步块的大小，但是如果一系列的连续操作都对同一个对象返回加锁解锁，甚至加解锁出现在循环内，也会导致不必要的损耗，如消除中举例代码，就可以把加锁同步范围扩展（粗化）到整个操作系列外部，第一个append之前到最后一个append之后。实现仅简化。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Lock</title>
      <link href="/2021/03/08/java/java-lock/"/>
      <url>/2021/03/08/java/java-lock/</url>
      
        <content type="html"><![CDATA[<p>Java中往往按照是否含有某一特性定义锁，这里也先根据特性将锁进行归类<br><img src="/images/java_lock.png"></p><h2 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁 - 悲观锁"></a>乐观锁 - 悲观锁</h2><p>乐观锁与悲观锁是一种广义上的概念，体现在对待线程同步的看法。在Java和数据库中都有此概念对应的实际应用。</p><p>对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。 而乐观锁认为不会有别的线程修改数据，先不加锁，只在更新数据时判断数据有没有被其他线程更新。</p><p><strong>悲观锁适合写操作多的场景，先加锁保证写操作正确</strong><br><strong>乐观锁适合读操作多的场景，不加锁提升并发性</strong></p><p>乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。<br>CAS虽然很高效，但是它也存在三大问题：</p><ol><li><p>ABA问题<br>ABA问题的解决思路就是在变量前面添加版本号，JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题</p></li><li><p>循环时间长开销大<br>CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</p></li><li><p>只能保证一个共享变量的原子操作<br>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</p></li></ol><h2 id="自旋锁-适应性自旋锁"><a href="#自旋锁-适应性自旋锁" class="headerlink" title="自旋锁 - 适应性自旋锁"></a>自旋锁 - 适应性自旋锁</h2><p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。</p><p>自旋要占用CPU，如果锁被占用时间较长，那只会浪费处理器资源，所以自旋必须有一个限度，如果超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应该挂起线程</p><p>自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p><p>自适应性自旋锁的自旋时间（次数）不再固定，由前一次在同一个锁上的<strong>自旋时间</strong>及<strong>锁的拥有者的状态</strong>来决定。同一个锁对象上，自旋等待杠成功获取锁且拥有锁的线程正在运行，虚拟机认为自旋成功概率较大，可适当延长自旋时间，</p><p>在自旋锁中 另有三种常见的锁形式:TicketLock、CLHlock和MCSlock，待后续细看</p><h2 id="无锁-偏向锁-轻量级锁-重量级锁"><a href="#无锁-偏向锁-轻量级锁-重量级锁" class="headerlink" title="无锁 - 偏向锁 - 轻量级锁 - 重量级锁"></a>无锁 - 偏向锁 - 轻量级锁 - 重量级锁</h2><p>这四种是指锁状态，针对<code>synchronized</code>, 它是悲观锁，在操作同步资源前先加锁，锁存放于对象头中<br>以Hotspot为例，对象头包括两部分，MarkWord和类型指针</p><ul><li>Mark Word<br>默认存储对象的HashCode，分代年龄和锁标志位信息</li><li>类型指针<br>指向对象的类元数据，虚拟机通过这个指针来确定这个对象是哪个类的实例</li></ul><p>锁膨胀：简单来说就是锁类型从偏向锁到轻量级锁再到重量级锁依次演变的过程。</p><ul><li>偏向锁：只有一个线程进入临界区；</li><li>轻量级锁：多个线程交替进入临界区；</li><li>重量级锁：多个线程同时进入临界区。</li></ul><h2 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁 - 非公平锁"></a>公平锁 - 非公平锁</h2><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。优点是等待锁的线程不会饿死，缺点是整体吞吐效率相对非公平锁要低，唤醒阻塞线程的开销比非公平锁大。</p><p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p><p>以<strong>ReentrantLock</strong>为例，ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。它有公平锁FairSync和非公平锁NonfairSync两个子类。ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"># <span class="token class-name">FairSync</span> 公平锁同步器<span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">final</span> <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"># 非公平锁同步器<span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">final</span> <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// overflow</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上图中的源代码对比，可以看出公平锁与非公平锁的lock()方法区别就在于公平锁在获取同步状态时多了一个限制条件hasQueuedPredecessors()【主要是判断当前线程是否位于同步队列中的第一个】 ,公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁.</p><h2 id="可重入锁-不可重入锁"><a href="#可重入锁-不可重入锁" class="headerlink" title="可重入锁 - 不可重入锁"></a>可重入锁 - 不可重入锁</h2><p>可重入锁是指在同一线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁</p><h2 id="独享锁-共享锁"><a href="#独享锁-共享锁" class="headerlink" title="独享锁 - 共享锁"></a>独享锁 - 共享锁</h2><p>独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。</p><p>共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p><p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享,如<code>ReentrantReadWriteLock</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ReentrantReadWriteLock<span class="token punctuation">.</span>ReadLock</span> readerLock<span class="token punctuation">;</span><span class="token comment">/** Inner class providing writelock */</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ReentrantReadWriteLock<span class="token punctuation">.</span>WriteLock</span> writerLock<span class="token punctuation">;</span><span class="token comment">/** Performs all synchronization mechanics */</span><span class="token keyword">final</span> <span class="token class-name">Sync</span> sync<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>AQS中使用<code>int state</code>标记有多少个线程持有锁，独享锁通常值为0或则1，共享锁就是持有锁的数量，但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态，低16位表示写锁状态（写锁个数）。如下图所示：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 写锁</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 取到当前锁的个数</span>        <span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 取写锁的个数w</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果已经有线程持有了锁(c!=0)</span>        <span class="token comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> current <span class="token operator">!=</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 如果写线程数（w）为0（换言之存在读锁） 或者持有锁的线程不是当前线程就返回失败</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">+</span> <span class="token function">exclusiveCount</span><span class="token punctuation">(</span>acquires<span class="token punctuation">)</span> <span class="token operator">></span> MAX_COUNT<span class="token punctuation">)</span>    <span class="token comment">// 如果写入锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error。</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// Reentrant acquire</span>        <span class="token function">setState</span><span class="token punctuation">(</span>c <span class="token operator">+</span> acquires<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">writerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c <span class="token operator">+</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 如果当且写线程数为0，并且当前线程需要阻塞那么就返回失败；或者如果通过CAS增加写线程数失败也返回失败。</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果c=0，w=0或者c>0，w>0（重入），则设置当前线程或锁的拥有者</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>首先取到当前锁的个数c，然后再通过c来获取写锁的个数w</strong>。因为写锁是低16位，所以取低16位的最大值与当前的c做与运算（ int w = exclusiveCount©; ），高16位和0与运算后是0，剩下的就是低位运算的值，同时也是持有写锁的线程数目。</li><li>取到写锁线程的数目后，首先判断是否已经有线程持有了锁。如果已经有线程持有了锁(c!=0)，则查看当前写锁线程的数目，如果写线程数不为0（即此时存在读锁）或者持有锁的线程不是当前线程就返回失败</li><li>如果写锁的数量大于最大数（65535，2的16次方-1）就抛出一个Error</li><li>如果当且写线程数为0（那么读线程也应该为0，因为上面已经处理c!=0的情况），并且当前线程需要阻塞那么就返回失败；如果通过CAS增加写线程数失败也返回失败。</li><li>如果c=0,w=0或者c&gt;0,w&gt;0（重入），则设置当前线程或锁的拥有者，返回成功</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 读锁</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">exclusiveCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> current<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                                   <span class="token comment">// 如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态</span>        <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">sharedCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">readerShouldBlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>        r <span class="token operator">&lt;</span> MAX_COUNT <span class="token operator">&amp;&amp;</span>        <span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> c <span class="token operator">+</span> SHARED_UNIT<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        firstReader <span class="token operator">=</span> current<span class="token punctuation">;</span>        firstReaderHoldCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>firstReader <span class="token operator">==</span> current<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        firstReaderHoldCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">HoldCounter</span> rh <span class="token operator">=</span> cachedHoldCounter<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rh <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> rh<span class="token punctuation">.</span>tid <span class="token operator">!=</span> <span class="token function">getThreadId</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span>        cachedHoldCounter <span class="token operator">=</span> rh <span class="token operator">=</span> readHolds<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rh<span class="token punctuation">.</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        readHolds<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>rh<span class="token punctuation">)</span><span class="token punctuation">;</span>        rh<span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token function">fullTryAcquireShared</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁，则当前线程增加读状态，成功获取读锁。读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是“1&lt;&lt;16”。所以读写锁才能实现读读的过程共享，而读写、写读、写写的过程互斥。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Reference</title>
      <link href="/2021/03/08/java/java-reference/"/>
      <url>/2021/03/08/java/java-reference/</url>
      
        <content type="html"><![CDATA[<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>Java中4种引用的强度由高到低依次为：强引用 -&gt; 软引用 -&gt; 弱引用 -&gt; 虚引用</p><table><thead><tr><th align="left">引用类型</th><th align="left">被垃圾回收时机</th><th>用途</th><th>生存时间</th></tr></thead><tbody><tr><td align="left">强引用</td><td align="left">从来不会</td><td>对象的一般状态</td><td>JVM停止运行时终止</td></tr><tr><td align="left">软引用</td><td align="left">当内存不足前</td><td>对象缓存</td><td>内存不足时终止</td></tr><tr><td align="left">弱引用</td><td align="left">GC一看到立刻回收</td><td>对象缓存</td><td>垃圾回收后终止</td></tr><tr><td align="left">虚引用</td><td align="left">随时随刻</td><td>跟踪对象的垃圾回收</td><td>垃圾回收后终止</td></tr></tbody></table><p>Java 引用类</p><ul><li>FinalReference，一种保底策略，因为GC只能管理自动内存资源而无法管理其它资源（如堆外内存、file handle、socket等），这些需要使用方手动对资源进行管理</li><li>SoftReference，软引用，只有在堆内存不足时，垃圾回收器会回收对应引用。所以比较适合用来实现不是特别重要的缓存</li><li>WeakReference，弱引用，每次垃圾回收都会回收其引用，一般在需要控制内存但又又想要尽量用到内存的场景下使用</li><li>PhantomReference，虚引用，对引用无影响，只用于获取对象被回收的通知。和软引用以及弱引用不同的是幻影引用指向的对象没有其他强引用、软引用指向时不会自动被GC清理。</li></ul><p>说明</p><ul><li>强引用没有对应的类型表示，也就是说强引用是普遍存在的，如Object object = new Object();</li><li>软引用、弱引用和虚引用都是java.lang.ref.Reference的直接子类。</li><li>直到JDK11为止，只存在四种引用，这些引用是由JVM创建，因此直接继承java.lang.ref.Reference创建自定义的引用类型是无效的，但是可以直接继承已经存在的引用类型，如java.lang.ref.Cleaner就是继承自java.lang.ref.PhantomReference。</li><li>特殊的java.lang.ref.Reference的子类java.lang.ref.FinalReference和Object#finalize()有关，java.lang.ref.Finalizer是java.lang.ref.FinalReference子类。</li></ul><h3 id="软引用-SoftReference"><a href="#软引用-SoftReference" class="headerlink" title="软引用 (SoftReference)"></a>软引用 (SoftReference)</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SoftReferenceMain</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span><span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SoftReferenceObject</span><span class="token punctuation">></span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">SoftReferenceObject</span> object <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReferenceObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SoftReferenceObject</span><span class="token punctuation">></span></span> reference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span>object <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>reference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SoftReferenceObject</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">120_000</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token string">"SoftReferenceObject"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 运行后输出结果</span><span class="token keyword">null</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="弱引用-WeakReference"><a href="#弱引用-WeakReference" class="headerlink" title="弱引用 (WeakReference)"></a>弱引用 (WeakReference)</h3><p>ThreadLocal</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalMap</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ThreadLocal</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>        <span class="token comment">/** The value associated with this ThreadLocal. */</span>        <span class="token class-name">Object</span> value<span class="token punctuation">;</span>        <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> k<span class="token punctuation">,</span> <span class="token class-name">Object</span> v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">super</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>            value <span class="token operator">=</span> v<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简单示例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WeakReferenceMain</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span><span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">WeakReferenceObject</span><span class="token punctuation">></span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">WeakReferenceObject</span> object <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReferenceObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">WeakReferenceObject</span><span class="token punctuation">></span></span> reference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span>object <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>reference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">WeakReferenceObject</span> <span class="token punctuation">&#123;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token string">"WeakReferenceObject"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 运行后输出结果</span><span class="token class-name">WeakReferenceObject</span><span class="token keyword">null</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="虚引用-PhantomReference"><a href="#虚引用-PhantomReference" class="headerlink" title="虚引用(PhantomReference)"></a>虚引用(PhantomReference)</h3><p>一个对象是否关联到虚引用，完全不会影响该对象的生命周期，也无法通过虚引用来获取一个对象的实例。 为对象设置一个虚引用的唯一目的是：能在此对象被垃圾收集器回收的时候收到一个系统通知。</p><p>PhantomReference有两个比较常用的子类是java.lang.ref.Cleaner和jdk.internal.ref.Cleaner，其中前者提供的功能是开发者用于在引用对象回收的时候触发一个动作(java.lang.ref.Cleaner$Cleanable)，后者用于DirectByteBuffer对象回收的时候对于堆外内存的回收，可以翻看前面描述java.lang.ref.Reference#processPendingReferences()源码的时候，ReferenceHandler线程会对pending链表中的jdk.internal.ref.Cleaner类型引用对象调用其clean()方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PhantomReferenceTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> referenceQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> phantomReference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span>referenceQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>phantomReference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Reference-amp-amp-ReferenceQueue"><a href="#Reference-amp-amp-ReferenceQueue" class="headerlink" title="Reference &amp;&amp; ReferenceQueue"></a>Reference &amp;&amp; ReferenceQueue</h2><h3 id="ReferenceQueue"><a href="#ReferenceQueue" class="headerlink" title="ReferenceQueue"></a>ReferenceQueue</h3><p>ReferenceQueue队列是一个单向链表，ReferenceQueue里面只有一个head 成员变量持有队列的队头。后进先出的队列，其实是个就是个栈!</p><p>ReferenceQueue和 Reference 类都是 jdk1.2 的时候出的，所以也就不可能继承jdk1.5出来的Queue接口</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>这是Reference对象的抽象base类，这个类定义了所有 reference 对象的通用方法，因为 reference 对象跟GC垃圾收集器密切相关.</p><p>源码说明</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">&#x2F;* The state of a Reference object is characterized by two attributes.  It* may be either &quot;active&quot;, &quot;pending&quot;, or &quot;inactive&quot;.  It may also be* either &quot;registered&quot;, &quot;enqueued&quot;, &quot;dequeued&quot;, or &quot;unregistered&quot;.**   Active: Subject to special treatment by the garbage collector.  Some*   time after the collector detects that the reachability of the*   referent has changed to the appropriate state, the collector*   &quot;notifies&quot; the reference, changing the state to either &quot;pending&quot; or*   &quot;inactive&quot;.*   referent !&#x3D; null; discovered &#x3D; null, or in GC discovered list.**   Pending: An element of the pending-Reference list, waiting to be*   processed by the ReferenceHandler thread.  The pending-Reference*   list is linked through the discovered fields of references in the*   list.*   referent &#x3D; null; discovered &#x3D; next element in pending-Reference list.**   Inactive: Neither Active nor Pending.*   referent &#x3D; null.**   Registered: Associated with a queue when created, and not yet added*   to the queue.*   queue &#x3D; the associated queue.**   Enqueued: Added to the associated queue, and not yet removed.*   queue &#x3D; ReferenceQueue.ENQUEUE; next &#x3D; next entry in list, or this to*   indicate end of list.**   Dequeued: Added to the associated queue and then removed.*   queue &#x3D; ReferenceQueue.NULL; next &#x3D; this.**   Unregistered: Not associated with a queue when created.*   queue &#x3D; ReferenceQueue.NULL.** The collector only needs to examine the referent field and the* discovered field to determine whether a (non-FinalReference) Reference* object needs special treatment.  If the referent is non-null and not* known to be live, then it may need to be discovered for possible later* notification.  But if the discovered field is non-null, then it has* already been discovered.** FinalReference (which exists to support finalization) differs from* other references, because a FinalReference is not cleared when* notified.  The referent being null or not cannot be used to distinguish* between the active state and pending or inactive states.  However,* FinalReferences do not support enqueue().  Instead, the next field of a* FinalReference object is set to &quot;this&quot; when it is added to the* pending-Reference list.  The use of &quot;this&quot; as the value of next in the* enqueued and dequeued states maintains the non-active state.  An* additional check that the next field is null is required to determine* that a FinalReference object is active.** Initial states:*   [active&#x2F;registered]*   [active&#x2F;unregistered] [1]** Transitions:*                            clear*   [active&#x2F;registered]     -------&gt;   [inactive&#x2F;registered]*          |                                 |*          |                                 | enqueue [2]*          | GC              enqueue [2]     |*          |                -----------------|*          |                                 |*          v                                 |*   [pending&#x2F;registered]    ---              v*          |                   | ReferenceHandler*          | enqueue [2]       |---&gt;   [inactive&#x2F;enqueued]*          v                   |             |*   [pending&#x2F;enqueued]      ---              |*          |                                 | poll&#x2F;remove*          | poll&#x2F;remove                     |*          |                                 |*          v            ReferenceHandler     v*   [pending&#x2F;dequeued]      ------&gt;    [inactive&#x2F;dequeued]***                           clear&#x2F;enqueue&#x2F;GC [3]*   [active&#x2F;unregistered]   ------*          |                      |*          | GC                   |*          |                      |--&gt; [inactive&#x2F;unregistered]*          v                      |*   [pending&#x2F;unregistered]  ------*                           ReferenceHandler** Terminal states:*   [inactive&#x2F;dequeued]*   [inactive&#x2F;unregistered]** Unreachable states (because enqueue also clears):*   [active&#x2F;enqeued]*   [active&#x2F;dequeued]** [1] Unregistered is not permitted for FinalReferences.** [2] These transitions are not possible for FinalReferences, making* [pending&#x2F;enqueued] and [pending&#x2F;dequeued] unreachable, and* [inactive&#x2F;registered] terminal.** [3] The garbage collector may directly transition a Reference* from [active&#x2F;unregistered] to [inactive&#x2F;unregistered],* bypassing the pending-Reference list.*&#x2F;一个引用对象可以同时存在两种状态：- 第一组状态：&quot;active&quot;, &quot;pending&quot;, or &quot;inactive&quot;- 第二组状态：&quot;registered&quot;, &quot;enqueued&quot;, &quot;dequeued&quot;, or &quot;unregistered&quot;Active：当前引用实例处于Active状态，会收到垃圾收集器的特殊处理。在垃圾收集器检测到referent的可达性已更改为适当状态之后的某个时间，垃圾收集器会&quot;通知&quot;当前引用实例改变其状态为&quot;pending&quot;或者&quot;inactive&quot;。此时的判断条件是：referent !&#x3D; null; discovered &#x3D; null或者实例位于GC的discovered列表中。Pending：当前的引用实例是pending-Reference列表的一个元素，等待被ReferenceHandler线程处理。pending-Reference列表通过应用实例的discovered字段进行关联。此时的判断条件是：referent &#x3D; null; discovered &#x3D; pending-Reference列表中的下一个元素Inactive：当前的引用实例处于非Active和非Pending状态。此时的判断条件是：referent &#x3D; null (同时discovered &#x3D; null)Registered：当前的引用实例创建的时候关联到一个引用队列实例，但是引用实例暂未加入到队列中。此时的判断条件是：queue &#x3D; 传入的ReferenceQueue实例Enqueued：当前的引用实例已经添加到和它关联的引用队列中但是尚未移除(remove)，也就是调用了ReferenceQueue.enqueued()后的Reference实例就会处于这个状态。此时的判断条件是：queue &#x3D; ReferenceQueue.ENQUEUE; next &#x3D; 引用列表中的下一个引用实例，或者如果当前引用实例是引用列表中的最后一个元素，则它会进入Inactive状态Dequeued：当前的引用实例曾经添加到和它关联的引用队列中并且已经移除(remove)。此时的判断条件是：queue &#x3D; ReferenceQueue.NULL; next &#x3D; 当前的引用实例Unregistered：当前的引用实例不存在关联的引用队列，也就是创建引用实例的时候传入的queue为null。此时的判断条件是：queue &#x3D; ReferenceQueue.NULL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/java_reference_main.png"></p><p>ReferenceQueue队列的作用就是Reference引用的对象被回收时，Reference对象能否进入到pending队列，最终由ReferenceHander线程处理后，Reference就被放到了这个队列里面（Cleaner对象除外），然后我们就可以在这个ReferenceQueue里拿到reference,执行我们自己的操作，所以这个队列起到一个对象被回收时通知的作用； </p><p>如果不带ReferenceQueue的话,要想知道Reference持有的对象是否被回收，就只有不断地轮训reference对象,通过判断get是否为null(phantomReference对象不能这样做)。这两种方法均有相应的使用场景,取决于实际的应用.如weakHashMap中就选择去查询queue的数据,来判定是否有对象将被回收.而ThreadLocalMap,则采用判断get()是否为null来作处理; </p><p>对于带ReferenceQueue参数的构造方法，如果传入的队列为null，那么就会给成员变量queue赋值为ReferenceQueue.NULL队列,这个NULL是ReferenceQueue对象的一个继承了ReferenceQueue的内部类，它重写了入队方法enqueue，这个方法只有一个操作，直接返回 false，也就是这个对列不会存取任何数据,它起到状态标识的作用； </p><p><strong><em>Cleaner对象是没有Enqueue状态的，它经过HandReference处理时执行其clean方法清理，然后就直接进入了inactive状态</em></strong></p><h2 id="Cleaner"><a href="#Cleaner" class="headerlink" title="Cleaner"></a>Cleaner</h2><p>sun.misc.Cleaner是JDK内部提供的用来释放非堆内存资源的API。JVM只会帮我们自动释放堆内存资源，但是堆外内存无能为力，该类提供了回调机制，通过这个类能方便的释放系统的其他资源。Cleaner 继承了 PhantomReference，是一个虚幻引用。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java魔法类 | Unsafe</title>
      <link href="/2021/03/08/java/java-unsafe/"/>
      <url>/2021/03/08/java/java-unsafe/</url>
      
        <content type="html"><![CDATA[<p>Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在JDK11中已经封闭了反射获取的途径</p><p>本文将对sun.misc.Unsafe公共API功能及相关应用场景进行介绍。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Unsafe</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">static</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//  获取方式一（被封）：封闭反射获取的途径</span>        <span class="token class-name">Reflection</span><span class="token punctuation">.</span><span class="token function">registerMethodsToFilter</span><span class="token punctuation">(</span><span class="token class-name">Unsafe</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">"getUnsafe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token class-name">Unsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Unsafe</span> theUnsafe <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Unsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name"><span class="token namespace">jdk<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>Unsafe</span> theInternalUnsafe <span class="token operator">=</span> <span class="token class-name"><span class="token namespace">jdk<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>Unsafe</span><span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@CallerSensitive</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Unsafe</span> <span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> caller <span class="token operator">=</span> <span class="token class-name">Reflection</span><span class="token punctuation">.</span><span class="token function">getCallerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>VM<span class="token punctuation">.</span><span class="token function">isSystemDomainLoader</span><span class="token punctuation">(</span>caller<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">SecurityException</span><span class="token punctuation">(</span><span class="token string">"Unsafe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> theUnsafe<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>那如若想使用这个类，该如何获取其实例？有如下两个可行方案。</p><p>其一，从getUnsafe方法的使用限制条件出发，通过Java命令行命令-Xbootclasspath/a把调用Unsafe相关方法的类A所在jar包路径追加到默认的bootstrap路径中，使得A被引导类加载器加载，从而通过Unsafe.getUnsafe方法安全的获取Unsafe实例。</p><p>java -Xbootclasspath/a: ${path}   // 其中path为调用Unsafe相关方法的类所在jar包路径<br>其二，通过反射获取单例对象theUnsafe。<br><img src="/images/java_unsafe.png"></p><p>如上图所示，Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障、数组操作等几类，下面将对其相关方法和应用场景进行详细介绍。</p><h2 id="内存操作"><a href="#内存操作" class="headerlink" title="内存操作"></a>内存操作</h2><p>这部分主要包含堆外内存的分配，拷贝，释放、给定地址值操作等方法</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">&#x2F;&#x2F;分配内存, 相当于C++的malloc函数public native long allocateMemory(long bytes);&#x2F;&#x2F;扩充内存public native long reallocateMemory(long address, long bytes);&#x2F;&#x2F;释放内存public native void freeMemory(long address);&#x2F;&#x2F;在给定的内存块中设置值public native void setMemory(Object o, long offset, long bytes, byte value);&#x2F;&#x2F;内存拷贝public native void copyMemory(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes);&#x2F;&#x2F;获取给定地址值，忽略修饰限定符的访问限制。与此类似操作还有: getInt，getDouble，getLong，getChar等public native Object getObject(Object o, long offset);&#x2F;&#x2F;为给定地址设置值，忽略修饰限定符的访问限制，与此类似操作还有: putInt,putDouble，putLong，putChar等public native void putObject(Object o, long offset, Object x);&#x2F;&#x2F;获取给定地址的byte类型的值（当且仅当该内存地址为allocateMemory分配时，此方法结果为确定的）public native byte getByte(long address);&#x2F;&#x2F;为给定地址设置byte类型的值（当且仅当该内存地址为allocateMemory分配时，此方法结果才是确定的）public native void putByte(long address, byte x);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="典型引用"><a href="#典型引用" class="headerlink" title="典型引用"></a>典型引用</h3><p>DirectByteBuffer是Java用于实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，如在Netty、MINA等NIO框架中应用广泛。DirectByteBuffer对于堆外内存的创建、使用、销毁等逻辑均由Unsafe提供的堆外内存API来实现。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">DirectByteBuffer</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                   <span class="token comment">// package-private</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> cap<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> pa <span class="token operator">=</span> VM<span class="token punctuation">.</span><span class="token function">isDirectMemoryPageAligned</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ps <span class="token operator">=</span> <span class="token class-name">Bits</span><span class="token punctuation">.</span><span class="token function">pageSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> size <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">1L</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>cap <span class="token operator">+</span> <span class="token punctuation">(</span>pa <span class="token operator">?</span> ps <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Bits</span><span class="token punctuation">.</span><span class="token function">reserveMemory</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> base <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        base <span class="token operator">=</span> UNSAFE<span class="token punctuation">.</span><span class="token function">allocateMemory</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">OutOfMemoryError</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Bits</span><span class="token punctuation">.</span><span class="token function">unreserveMemory</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    UNSAFE<span class="token punctuation">.</span><span class="token function">setMemory</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pa <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>base <span class="token operator">%</span> ps <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Round up to page boundary</span>        address <span class="token operator">=</span> base <span class="token operator">+</span> ps <span class="token operator">-</span> <span class="token punctuation">(</span>base <span class="token operator">&amp;</span> <span class="token punctuation">(</span>ps <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        address <span class="token operator">=</span> base<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 跟踪DirectByteBuffer对象的垃圾回收，实现堆外内存释放</span>    cleaner <span class="token operator">=</span> <span class="token class-name">Cleaner</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Deallocator</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> size<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    att <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="如何通过构建垃圾回收追踪对象Cleaner实现堆外内存释放呢？"><a href="#如何通过构建垃圾回收追踪对象Cleaner实现堆外内存释放呢？" class="headerlink" title="如何通过构建垃圾回收追踪对象Cleaner实现堆外内存释放呢？"></a>如何通过构建垃圾回收追踪对象Cleaner实现堆外内存释放呢？</h4><p>Cleaner继承自Java四大引用类型之一的虚引用PhantomReference，通常PhantomReference与引用队列ReferenceQueue结合使用，可以实现虚引用关联对象被垃圾回收时能够进行系统通知、资源清理等功能。如下图所示，当某个被Cleaner引用的对象将被回收时，JVM垃圾收集器会将此对象的引用放入到对象引用中的pending链表中，等待Reference-Handler进行相关处理。其中，Reference-Handler为一个拥有最高优先级的守护线程，会循环不断的处理pending链表中的对象引用，执行Cleaner的clean方法进行相关清理工作。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// java.lang.ref.Reference.ReferenceHandler</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">processPendingReferences</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">waitForReferencePendingList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Reference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> pendingList<span class="token punctuation">;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>processPendingLock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            pendingList <span class="token operator">=</span> <span class="token function">getAndClearReferencePendingList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            processPendingActive <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>pendingList <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Reference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> ref <span class="token operator">=</span> pendingList<span class="token punctuation">;</span>            pendingList <span class="token operator">=</span> ref<span class="token punctuation">.</span>discovered<span class="token punctuation">;</span>            ref<span class="token punctuation">.</span>discovered <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token comment">// 判断是否为Cleaner</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ref <span class="token keyword">instanceof</span> <span class="token class-name">Cleaner</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Cleaner</span><span class="token punctuation">)</span>ref<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">clean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>processPendingLock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    processPendingLock<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">Object</span><span class="token punctuation">></span></span> q <span class="token operator">=</span> ref<span class="token punctuation">.</span>queue<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> <span class="token class-name">ReferenceQueue</span><span class="token punctuation">.</span>NULL<span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>ref<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>processPendingLock<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            processPendingActive <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            processPendingLock<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当DirectByteBuffer仅被Cleaner引用（即为虚引用）时，其可以在任意GC时段被回收。当DirectByteBuffer实例对象被回收时，在Reference-Handler线程操作中，会调用Cleaner的clean方法根据创建Cleaner时传入的Deallocator来进行堆外内存的释放。</p><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//取消阻塞线程</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">unpark</span><span class="token punctuation">(</span><span class="token class-name">Object</span> thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//阻塞线程</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> isAbsolute<span class="token punctuation">,</span> <span class="token keyword">long</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获得对象锁（可重入锁）</span><span class="token annotation punctuation">@Deprecated</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">monitorEnter</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//释放对象锁</span><span class="token annotation punctuation">@Deprecated</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">monitorExit</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//尝试获取对象锁</span><span class="token annotation punctuation">@Deprecated</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">tryMonitorEnter</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>典型应用</em></strong></p><p>Java锁和同步器框架的核心类AbstractQueuedSynchronizer，就是通过调用LockSupport.park()和LockSupport.unpark()实现线程的阻塞和唤醒的，而LockSupport的park、unpark方法实际是调用Unsafe的park、unpark方式来实现。</p><h3 id="Class相关"><a href="#Class相关" class="headerlink" title="Class相关"></a>Class相关</h3><p>此部分主要提供Class和它的静态字段的操作相关方法，包含静态字段内存定位、定义类、定义匿名类、检验&amp;确保初始化等。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//获取给定静态字段的内存地址偏移量，这个值对于给定的字段是唯一且固定不变的</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">long</span> <span class="token function">staticFieldOffset</span><span class="token punctuation">(</span><span class="token class-name">Field</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取一个静态类中给定字段的对象指针</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token class-name">Object</span> <span class="token function">staticFieldBase</span><span class="token punctuation">(</span><span class="token class-name">Field</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//判断是否需要初始化一个类，通常在获取一个类的静态属性的时候（因为一个类如果没初始化，它的静态属性也不会初始化）使用。 当且仅当ensureClassInitialized方法不生效时返回false。</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">shouldBeInitialized</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//检测给定的类是否已经初始化。通常在获取一个类的静态属性的时候（因为一个类如果没初始化，它的静态属性也不会初始化）使用。</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">ensureClassInitialized</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//定义一个类，此方法会跳过JVM的所有安全检查，默认情况下，ClassLoader（类加载器）和ProtectionDomain（保护域）实例来源于调用者</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">defineClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> off<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">,</span> <span class="token class-name">ClassLoader</span> loader<span class="token punctuation">,</span> <span class="token class-name">ProtectionDomain</span> protectionDomain<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//定义一个匿名类</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> <span class="token function">defineAnonymousClass</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> hostClass<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cpPatches<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>典型应用</strong></p><p>Java 8开始，JDK使用invokedynamic及VM Anonymous Class结合来实现Java语言层面上的Lambda表达式。</p><ul><li>invokedynamic： invokedynamic是Java7为了实现在JVM上运行动态语言而引入，可以实现在运行期动态解析出调用点限定符所引用的方法，然后再执行该方法，invokedynamic指令的分派逻辑是由用户设定的引导方法决定。</li><li>VM Anonymous Class：可以看做是一种模板机制，针对于程序动态生成很多结构相同、仅若干常量不同的类时，可以先创建包含常量占位符的模板类，而后通过Unsafe.defineAnonymousClass方法定义具体类时填充模板的占位符生成具体的匿名类。生成的匿名类不显式挂在任何ClassLoader下面，只要当该类没有存在的实例对象、且没有强引用来引用该类的Class对象时，该类就会被GC回收。故而VM Anonymous Class相比于Java语言层面的匿名内部类无需通过ClassClassLoader进行类加载且更易回收。</li></ul><p>在Lambda表达式实现中，通过invokedynamic指令调用引导方法生成调用点，在此过程中，会通过ASM动态生成字节码，而后利用Unsafe的defineAnonymousClass方法定义实现相应的函数式接口的匿名类，然后再实例化此匿名类，并返回与此匿名类中函数式方法的方法句柄关联的调用点；而后可以通过此调用点实现调用相应Lambda表达式定义逻辑的功能。下面以如下图所示的Test类来举例说明。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LambdaTest</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> consumer <span class="token operator">=</span> s <span class="token operator">-></span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        consumer<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token string">"lambda test."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>javap -c LambdaTest.class</code></p><pre class="line-numbers language-text" data-language="text"><code class="language-text">public class com.star.account.juc.LambdaTest &#123;  public com.star.account.juc.LambdaTest();    Code:       0: aload_0       1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V       4: return  public static void main(java.lang.String[]);    Code:       0: invokedynamic #2,  0              &#x2F;&#x2F; InvokeDynamic #0:accept:()Ljava&#x2F;util&#x2F;function&#x2F;Consumer;       5: astore_1       6: aload_1       7: ldc           #3                  &#x2F;&#x2F; String lambda test.       9: invokeinterface #4,  2            &#x2F;&#x2F; InterfaceMethod java&#x2F;util&#x2F;function&#x2F;Consumer.accept:(Ljava&#x2F;lang&#x2F;Object;)V      14: return&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>这部分主要介绍与数据操作相关的arrayBaseOffset与arrayIndexScale这两个方法，两者配合起来使用，即可定位数组中每个元素在内存中的位置</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//返回数组中第一个元素的偏移地址</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">arrayBaseOffset</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> arrayClass<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回数组中一个元素占用的大小</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">arrayIndexScale</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> arrayClass<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h3><p>Java8引入，用于定义内存屏障（也称屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作），避免代码重排序。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">loadFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//内存屏障，禁止store操作重排序。</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">storeFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//内存屏障，禁止load、store操作重排序</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">fullFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><em>典型应用</em></strong></p><p>Java8中引入了一种锁的新机制——StampedLock，它可以看成是读写锁的一个改进版本。StampedLock提供了一种乐观读锁的实现，这种乐观读锁类似于无锁的操作，完全不会阻塞写线程获取写锁，从而缓解读多写少时写线程“饥饿”现象。由于StampedLock提供的乐观读锁不阻塞写线程获取读锁，当线程共享变量从主内存load到线程工作内存时，会存在数据不一致问题，所以当使用StampedLock的乐观读锁时，需要遵从如下图用例中使用的模式来确保数据的一致性。</p><h3 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//返回系统指针的大小。返回值为4（32位系统）或 8（64位系统）。</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">addressSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//内存页的大小，此值为2的幂次方。</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">pageSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用</p><p>java.nio.Bits.pageSize<br>工具类Bits中计算待申请内存所需内存页数量的静态方法，其依赖于Unsafe中pageSize方法获取系统内存页大小实现后续计算逻辑。</p><h3 id="对象操作"><a href="#对象操作" class="headerlink" title="对象操作"></a>对象操作</h3><p>此部分主要包含对象成员属性相关操作及非常规的对象实例化等相关方法<br> <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//返回对象成员属性在内存地址相对于此对象的内存地址的偏移量</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">long</span> <span class="token function">objectFieldOffset</span><span class="token punctuation">(</span><span class="token class-name">Field</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获得给定对象的指定地址偏移量的值，与此类似操作还有：getInt，getDouble，getLong，getChar等</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token class-name">Object</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//给定对象的指定地址偏移量设值，与此类似操作还有：putInt，putDouble，putLong，putChar等</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">putObject</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> <span class="token class-name">Object</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//从对象的指定偏移量处获取变量的引用，使用volatile的加载语义</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token class-name">Object</span> <span class="token function">getObjectVolatile</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//存储变量的引用到对象的指定的偏移量处，使用volatile的存储语义</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">putObjectVolatile</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> <span class="token class-name">Object</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//有序、延迟版本的putObjectVolatile方法，不保证值的改变被其他线程立即看到。只有在field被volatile修饰符修饰时有效</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">putOrderedObject</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> <span class="token class-name">Object</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//绕过构造方法、初始化代码来创建对象</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token class-name">Object</span> <span class="token function">allocateInstance</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> cls<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InstantiationException</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>典型应用</p><ul><li>常规对象实例化方式：我们通常所用到的创建对象的方式，从本质上来讲，都是通过new机制来实现对象的创建。但是，new机制有个特点就是当类只提供有参的构造函数且无显示声明无参构造函数时，则必须使用有参构造函数进行对象构造，而使用有参构造函数时，必须传递相应个数的参数才能完成对象实例化。</li><li>非常规的实例化方式：而Unsafe中提供allocateInstance方法，仅通过Class对象就可以创建此类的实例对象，而且不需要调用其构造函数、初始化代码、JVM安全检查等。它抑制修饰符检测，也就是即使构造器是private修饰的也能通过此方法实例化，只需提类对象即可创建相应的对象。由于这种特性，allocateInstance在java.lang.invoke、Objenesis（提供绕过类构造器的对象生成方式）、Gson（反序列化时用到）中都有相应的应用。</li></ul><p><strong>Objenesis</strong>Spring CGlib代理类创建的默认方式</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
