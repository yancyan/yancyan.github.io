---
title: 类加载机制
date: 2021-03-11 21:11:00
author: yancyan
categories: 虚拟机
tags:
- JVM
---

## 介绍
Java虚拟机把描述类的Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可被虚拟机使用的Java类型，这个过程被称作虚拟机的类加载机制。


## 加载时机
一个类型从被加载到虚拟机内存开始到卸载出内存为止，这个生命周期要经历加载、验证、准备、解析、初始化、使用和卸载七个阶段，如下图
![类的生命周期](/images/java_class_loader.png)
其中加载、验证、准备、初始化和卸载这五个阶段是顺序（开始的顺序，执行阶段可能会交叉）确定的。解析阶段则不一定，某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定特性。

对于初始化阶段，《Java虚拟机规范》严格规定了**有且仅有**六种情况下必须对类进行”初始化“
1. 遇到new、getstatic、putstatic、和invokestatic这四条字节码指令时
    - new关键字实例化对象
    - 读取和设置一个类型的静态字段（final修饰，已在编译器放入常量池的静态字段除外）
    - 调用一个类型的静态方法
    
2. 使用反射对类型进行反射调用
3. 初始化类时，如果父类还未初始化要先对父类进行初始化
4. 虚拟机启动，用户需要指定要执行的主类
5. 当使用JDK7新加入的动态语言支持时，如果`java.lang.invoke.MethHandle`实例最后的解析结果为REF_getStatic\REF_putStatic\REF_invokeStatic\REF_newInvokeSpecial四种类型的方法句柄
6. 当一个接口中定义了JDK8新加入的默认方法，如果这个接口的实现类进行了初始化，那这个接口也要在之前进行初始化


## 加载过程
### 加载
加载阶段虚拟机需要完成三件事
1. 通过一个类的全限定名获取二进制字节流
2. 将这个字节流代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的Class对象，最为方法区这个类的各种数据访问入口

虚拟机规范对这三点要求并不特别具体，所以虚拟机实现的灵活度很大，”通过一个类的全限定名获取二进制字节流“衍生了很多技术
- 从ZIP压缩包中读取，最终形成了JAR.EAR,WAR格式的基础
- 从网络中获取，典型的WebApplet
- 运行时计算生成，如动态代理技术
- 由其他文件生成， 典型场景JSP应用
- 从数据库读取
- 从加密文件中获取
- ...

数组比较特殊，数组类本身不通过类加载器创建，是由Java虚拟机直接在内存中动态构造出阿里，但是数组类的元素类型最终还是要靠类加载器完成加载，一个数组类创建过程遵循一下规则：
- 数组的元素类型是引用类型，递归加载这些引用类型，数组类被标识在加载数组元素类型的类加载器的类名空间上
- 如果数组元素不是引用类型，虚拟机将会把数组类标记为与引导类加载器关联
- 数组类的可访问性和它的元素类型的可访问性一致，如果元素类型不是引用类，那数组类的可访问性默认public，

加载结束后，外部的二进制字节流就按照虚拟机设定的格式存储在方法区。类型数据放到方法区以后，会在Java堆内存中实例化一个Class类对象，这个类对象作为程序访问方法区的类型数据的外部入口。


### 验证
验证是连接的第一步，确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束。
大致分为四个阶段的检验动作：文件格式验证、元数据验证、字节码验证和符号引用验证
#### 1. 文件格式验证
该验证阶段的主要目的是保证输入的字节流能正确的解析并存储在方法区内，格式上符合一个类型信息的要求。此阶段基于二进制字节流进行，验证通过后字节流被允许进入方法区，所以后边的三个结算都是基于方法区的存储结构上进行，不用在读取和操作字节流。

验证点包含：
- 是否以魔数0xCAFFEBABE开头
- 主、次版本号是否在范围内
- 常量池的常量是否由不被支持的常量类型
- 指向常量的各种索引值是否指向不存在的常量
- ...


#### 2. 元数据验证
对字节码描述的信息进行语义分析，保证其描述信息符合《Java语言规范》的要求，这个阶段可能包含的验证点如下
- 这个类是否有父类（除了Object，其他都应该有父类）
- 这个类的父类是否继承了不被允许的类（final修饰）
- 如果不是抽象类，是否实现了父类或接口中的方法
- ...

#### 3. 字节码验证
字节码校验是整个验证过程最复杂的一个阶段，主要是通过数据流分析和控制流分析，确定程序语义的合法性，和逻辑性。这阶段主要是对类的方法体进行校验分析，保证类方法的安全，如：
- 保证任意时刻，操作数栈的数据类型与指令代码序列都能配合工作
- 保证任何跳转指令都不会跳转到方法体以外的字节码指令上
- 保证方法体内的类型转换总是有效的
- ...

虚拟机设计团队为了避免在字节码验证阶段进行耗时过长的数据流和控制流分析，在JDK6之后的javac编译器和虚拟机里进行了一项联合优化，尽可能的把验证辅助措施挪到了javac编译器里进行，具体做法是


JDK6的Hotspot提供了-XX：-UseSplitVerifier来关闭这项优化，或则使用参数-XX:+FailOverToOldVerifier要求在类型校验失败时退回到旧的类型推导方式校验。到了JDK7以后，只能使用类型检查完成数据流分析校验。

#### 4. 符号引用验证
目的是确保解析行为正常进行，这一阶段的行为发生在虚拟机将符号引用转化为直接引用的时候，这个动作将在连接的第三个阶段-解析阶段发生。

可看作是对类自身以外的各类信息进行匹配性校验，即该类是否缺少或则被禁止访问它依赖的某些外部类，方法，字段等，本阶段主要验证：
- 符号引用中通过字符串描述的全限定名是否能找到对应的类
- 指定类中是否存在符合方法的字段描述及简单名称所描述的方法和字段
- 符号引用中的类，字段，方法的可访问性是否可被当前类访问。
- ...

### 准备
准备阶段会正式为类中定义的变量（静态变量）分配内存并设置类变量初始值（数据类型的零值）。JDK8及以后，类变量随着Class对象一起存放在堆内存中。

对于类型零值，如
````java
public static int value = 124;
````
变量value准备阶段以后的初始值为0，而不是124. 而124的赋值指令是程序被编译后，存放在类构造器`<clinit>()`方法中，所以要等到类的初始化阶段。各类型的零值如下

数据类型| 零值    | 数据类型 | 零值
--- | --- | --- | ---
int|0 | boolean| false
long|0L|float|0.0f
short|(short)0|double|0.0D
char|'\u0000'|reference|null
byte|(byte)0|||

如果类字段的字段属性表中存在ConstantValue属性，在准备阶段变量值就会被初始化为ConstantValue

> public static **final** int value = 124

Javac将会为value生产ConstantValue属性，在准备阶段就会将value设置为124.

### 解析
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程
- 符号引用
符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时可以无歧义的定位到目标即可

- 直接引用
直接引用是可以直接指向目标的指针，相对偏移量或则一个能间接定位到目标的句柄。

### 初始化
初始化阶段就是执行类构造器<clinit>()方法的过程，
- `<clinit>()`方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块（static{}）中的语句合并而成，顺序是语句在源文件中的顺序。静态语句块中只能访问到定义在语句块之前的变量，定义其后的变量，可以赋值不能访问
- `<clinit>()`方法执行前先执行父类的此方法，所以父类的静态语句块也要先于子类执行
- `<clinit>()`方法对于类或接口不是必须的，如果没有静态代码块或则赋值，编译器也可以不生产此方法
- 接口中不能使用静态代码块，但是由变量初始化操作，因此接口和类一样都会有`<clinit>()`方法，但是不同的是接口执行时不需要先执行父类的`<clinit>()`方法，因为只有当父接口中定义的变量被使用时，父接口才会被实例化，此外接口的实现类在初始化时也一样不会执行接口的`<clinit>()`方法。
- 虚拟机保证一个类的`<clinit>()`方法在多线程环境中被正确的加锁同步，

## 类加载器
对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每个类加载器都拥有一个独立的类名称空间。

### 双亲委派模型
对于Java虚拟机来说，存在两种不同的类加载器，启动类加载器（C++编写）和其他所有的类加载器（Java编写，全部继承自java.lang.ClassLoader, 存在与虚拟机外部 ）

对于开发角度，分三大类
- 启动类加载器
- 扩展类加载器
- 应用程序类加载器

类加载器的“双亲委派模型”要求除了顶层的启动类加载器，其他的都应有自己的父类加载器，这里的父子关系是通过组合的方式来复用父类加载器的代码。

双亲委派模型的工作过程：一个类加载器收到加载类的请求，先将此请求转发给自己的父类加载完成，每一层都是如此，因此所有的请求都会从启动类加载器开始尝试加载，只有父类返回无法加载，子类加载器才会自己去完成。

### 破坏双亲委派模型
“双亲”模型不是强制约束的，而是推荐给我们的类加载是实现方式，到Java的模块化出现，出现过“被破坏”情况。

1. 双亲委派模型在引入之前已经存在破坏它的代码存在了。 双亲委派模型在 JDK 1.2 之后才被引入，而类加载器和抽象类 java.lang.ClassLoader 则在 JDK 1.0 时代就已经存在，JDK 1.2之后，其添加了一个新的 protected 方法 findClass()，在此之前，用户去继承 ClassLoader 类的唯一目的就是为了重写 loadClass() 方法，而双亲委派的具体逻辑就实现在这个方法之中，JDK 1.2 之后已不提倡用户再去覆盖 loadClass() 方法，而应当把自己的类加载逻辑写到 findClass() 方法中，这样就可以保证新写出来的类加载器是符合双亲委派规则的。

2. 基础类无法调用类加载器加载用户提供的代码。 双亲委派很好地解决了各个类加载器的基础类的统一问题，但如果基础类又要调用用户的代码，例如 JNDI 服务，JNDI现在已经是 Java 的标准服务，它的代码由启动类加载器去加载（在 JDK 1.3 时放进去的 rt.jar ），但JNDI需要调用由独立厂商实现并部署在应用程序的 ClassPath 下的 JNDI 接口提供者（SPI，例如JDBC驱动就是由 MySQL 等接口提供者提供的）的代码，但启动类加载器只能加载基础类，无法加载用户类。
>为此 Java 引入了线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过 java.lang.Thread.setContextClassLoaser() 方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。
如此，JNDI 服务使用这个线程上下文类加载器去加载所需要的 SPI 代码，也就是父类加载器请求子类加载器去完成类加载的动作。




















