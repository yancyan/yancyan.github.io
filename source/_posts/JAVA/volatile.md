---
title: Volatile
date: 2021-03-13 09:38:00
author: yancyan
categories: Java
tags:
- JAVA
---

## 介绍
Volatile可以说是虚拟机提供的最轻量的同步机制，Java内存模型也为其定义了特殊的访问规则。
两项特性：
1. 此关键字定义的变量对所以线程的可见性；
   volatile变量在各线程的工作内存中不存在一致性问题（物理存储值可能不一致，但是每次使用前都要刷新，执行引擎看不到不一致情况）
2. 禁止指令重排序优化
    Java在保证“线程内表现为串行语义”的前提下对指令进行重排序优化
   
## 线程的可见性
Volatile变量在各个线程都是一致的，但是不能保证对此变量的操作都是线程安全的，Java里的运算符并非原子操作，如`ract++`反编译以后得到的结果是由4条字节码指令构成，这四条指令不能保证原子性，指令如下：
```text
    0: getstatic
    3: iconst_1
    4: iadd
    5: putstatic
```
即使编译出来的是一条字节码指令，也不意味者这条指令就是原子操作指令，字节码在解释执行时，解释器要多条代码才能实现它的语义，在编译执行时，也可能被转化成若干本地机器码。可以使用-XX:+PrintAssembly输出反汇编。

不符合一下两条规则的场景，依然要通过加锁保证原子性
- 运算结果不依赖变量当前值，或确保仅一个线程会对其进行修改；
- 变量不需要和其他状态变量一起参与不变约束

适用场景举例，当shutdown被调用时，能保证所以线程中的doWork都停下来
```java
volatile boolean shutdownRe;
public void shutdown(){
    shutdownRe = true;
        }
        public void doWork(){
    while(!shutdownRe){
        // business code。。。
        }
        }

```
## 禁止指令重排序
> volatile屏蔽指令重排序的语义在JDK5才被完全修复，即之前利用此机制实现的双锁检测实现单例模式依然不安全

普通变量仅保证在执行过程中依赖其赋值的地方获取结果正确，而不保证变量赋值操作的顺序

可以通过HSDIS插件获取编译的汇编，通过比较可以发现volatile变量在赋值后紧跟了一条“Lock addl XXX"指令，其相当于一个内存屏障，强制所有在屏障指令之前的指令，都在该屏障指令执行之前被执行，并把缓冲区的数据写回主内存同时失效其他内核中该数据的缓存。